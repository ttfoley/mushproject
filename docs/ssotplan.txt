**Version:** 1.1 (Clarified references to ADR-013 for uC Pydantic models and autogen_config.h)
**Date:** 2025-05-20
**Overall Goal:** To transition the entire Mushroom Automation System V2 to a validated Single Source of Truth (SSOT) centered around `system_definition.yaml`. This involves finalizing Pydantic schemas, migrating existing configurations, enhancing `build.py` for comprehensive validation and artifact generation (including `autogen_config.h` for microcontrollers and a `global_point_registry.json`), and ensuring system-wide consistency. This plan draws from ADR-013 and the "Mushroom Automation System V2 - SSOT Implementation Plan & Next Steps (3).pdf".

### Phase 1: SSOT Core Definitions & Pydantic Schema Finalization

*Goal: Establish the definitive structure for all configuration YAMLs and the Pydantic models that validate them.*

- **Task 1.1: Finalize `system_definition.yaml` Structure and Content Rules (Ref: ADR-013 Sec.II.A, SSOT Plan PDF Decision 1)**
    - [ ]  `[ ]` Define `global_settings` structure (e.g., `mqtt_topic_prefix`, default `mqtt_broker`, default `ntp_server`).
    - [ ]  `[ ]` Finalize structure for the `components:` list (microcontrollers, drivers, governors). For each component:
        - `id`: Unique string identifier (becomes `source_component_id`).
        - `name`: Human-readable name.
        - `component_type`: e.g., "microcontroller", "driver", "governor".
        - `config_file`: Path to its component-specific YAML configuration.
        - `points_provided` (for microcontrollers) / `virtual_points_provided` (for drivers/governors): List of UUIDs (from the master `points:` list) that this component sources/manages.
    - [ ]  `[ ]` Finalize structure for the master `points:` list. For each point, ensure all attributes from ADR-013 Section II.A are covered:
        - `uuid`, system-wide functional `name`, `description`, `value_type`, `units`, `data_source_layer` (required), `access`, `writable_by`, `readback_point_uuid`, `persist_to_db` (required, with a system default if appropriate), `validation_rules`, logical `initial_value`.
    - [ ]  `[ ]` Document conventions for choosing system-wide functional `name`s (Principle #6 in ADR-013).
- **Task 1.2: Finalize Pydantic Models in `core_ssot_models.py` for `system_definition.yaml` (Ref: SSOT Plan PDF Decision 2)**
    - [ ]  `[ ]` Implement/Refine Pydantic models: `SystemDefinition`, `GlobalSettings`, `ComponentDefinition` (with variants for microcontroller, driver, governor if needed), `PointDefinition`.
    - [ ]  `[ ]` Ensure `PointDefinition` includes all attributes from Task 1.1 and ADR-013 Section II.A. Enforce `data_source_layer` and `persist_to_db` as required.
- **Task 1.3: Finalize Pydantic Models in `component_configs.py` for all Component Types (Ref: ADR-013 Sec.II.B, SSOT Plan PDF Decision 2 & Task B)**
    - [ ]  `[ ]` **MicrocontrollerConfig:**
        - [ ]  `[ ]` Implement the `MicrocontrollerConfig` Pydantic model and its `HardwarePoint` submodels (`ActuatorHardwarePoint`, `SensorDataHardwarePoint`, `SystemInfoHardwarePoint`) **as specified in "ADR-013: Naming, UUIDs, SSOT, and Information Locus for System Points", Section 1 ("Pydantic Models for Microcontroller Configuration").** This includes fields for local `name`, `point_kind`, `pin`, `pin_mode`, hardware `initial_state`, relevant `mqtt_topic_suffix_*`, and UUID reference fields (`write_point_uuid_ref`, `readback_point_uuid_ref`, `data_point_uuid_ref`).
        - [ ]  `[ ]` Ensure it also includes `device_id`, `description`, `wifi`, optional `mqtt_broker` & `ntp_server` overrides, `timing_constants`.
    - [ ]  `[ ]` **DriverConfig:**
        - [ ]  `[ ]` Implement the `DriverConfig` Pydantic model as detailed in ADR-013, Section II.B.2.
        - Include `component_id`, `input_points` (list of consumed UUIDs), `output_points` and `internal_state_points` (list of dicts: `uuid`, local `name`, `mqtt_topic_suffix_data`), `setpoint_input_points` (list of dicts: `uuid`, local `name`), and FSM structures.
    - [ ]  `[ ]` **GovernorConfig:**
        - [ ]  `[ ]` Implement the `GovernorConfig` Pydantic model as detailed in ADR-013, Section II.B.3.
        - Include `component_id`, `input_points`, `output_points`, `internal_state_points`, and logic parameters.
    - [ ]  `[ ]` Ensure local `name` fields in component configs follow derivation conventions (Principle #7 in ADR-013).
- **Task 1.4: Create/Update Sample YAML files for `system_definition.yaml` and each Component Type (Ref: SSOT Plan PDF Task B)**
    - [ ]  `[ ]` Create comprehensive, valid sample YAML files that exercise all Pydantic model features and demonstrate the intended configuration structure, consistent with ADR-013 examples.

### Phase 2: Configuration Data Migration to New SSOT YAMLs

*Goal: Translate all existing configuration data into the new, validated SSOT YAML structure.* (Based on SSOT Plan PDF "Phase 1 - Configuration Migration")

- **Task 2.1: Analyze Old Configs & Define Migration Mapping Strategy (Ref: SSOT Plan PDF Ticket 6.1)**
    - [ ]  `[ ]` Identify all old configuration sources (e.g., `microc_points.json`, `uuid_db.json`, driver `settings.json`, `transitions.json`, `states.json`, hardcoded values).
    - [ ]  `[ ]` Document old structures and data meanings.
    - [ ]  `[ ]` Finalize UUID migration strategy (generate new UUIDv4s, create old_id -> new_uuid mapping if needed for historical data correlation).
    - [ ]  `[ ]` Create a detailed mapping document: old fields/concepts -> new Pydantic schemas (`PointDefinition`, `MicrocontrollerConfig`, `DriverConfig`, etc.). Define rules for determining `data_source_layer`, `access`, `writable_by`, `units`, logical `initial_value`, etc.
- **Task 2.2: Implement Point Migration to `system_definition.yaml` (Ref: SSOT Plan PDF Ticket 6.2)**
    - [ ]  `[ ]` Process old point data based on mapping from Task 2.1.
    - [ ]  `[ ]` For each point:
        - Assign/migrate UUID.
        - Define system-wide functional `name` according to ADR-013, Principle #6.
        - Populate all attributes as per `PointDefinition` model (ADR-013 Section II.A). Ensure `units` are standardized (e.g., "on/off" lowercase).
        - Correctly link command and readback points using `readback_point_uuid`.
    - [ ]  `[ ]` Populate the `points:` list in the target `system_definition.yaml`.
    - [ ]  `[ ]` Validate frequently using `build.py` (Stage 1 validation).
- **Task 2.3: Implement Component Migration to `system_definition.yaml` (Ref: SSOT Plan PDF Ticket 6.3)**
    - [ ]  `[ ]` Identify all distinct component instances (microcontrollers, drivers, governors).
    - [ ]  `[ ]` Assign unique `id` to each (e.g., "c1", "temp_driver_fruiting").
    - [ ]  `[ ]` Specify `component_type`, human-readable `name`, and correct `config_file` path.
    - [ ]  `[ ]` Populate `points_provided` / `virtual_points_provided` for each component using the new UUIDs from Task 2.2.
    - [ ]  `[ ]` Populate the `components:` list in `system_definition.yaml`.
    - [ ]  `[ ]` Validate frequently using `build.py` (Stage 1 validation).
- **Task 2.4: Migrate Microcontroller Hardware Configs to Component YAMLs (Ref: SSOT Plan PDF Ticket 6.5, ADR-013)**
    - [ ]  `[ ]` For each microcontroller instance defined in Task 2.3:
        - Create its specific YAML file (e.g., `control/config/microcontrollers/c1_config.yaml`).
        - Populate `device_id` (matching component `id`), `wifi`, optional MQTT/NTP overrides, `timing_constants`.
        - Populate `hardware_points` list according to the `MicrocontrollerConfig` Pydantic model and ADR-013, Section II.B.1:
            - Use local `name` (derived: component `id` + functional part of master name).
            - Set `point_kind`.
            - Include `write_point_uuid_ref`, `readback_point_uuid_ref`, or `data_point_uuid_ref` linking to UUIDs from `system_definition.yaml`.
            - Define `pin`, `pin_mode`, hardware `initial_state` (e.g., `LOW`/`HIGH`), `mqtt_topic_suffix_*` (e.g., `_write`, `_readback`, `_data`).
    - [ ]  `[ ]` Validate each file using `build.py` (Stage 2 validation).
- **Task 2.5: Migrate Driver FSM Configs to Component YAMLs (Ref: SSOT Plan PDF Ticket 6.4)**
    - [ ]  `[ ]` For each driver instance:
        - Translate old FSM logic into the new `DriverConfig` YAML format (states, transitions, defining_conditions, actions targeting UUIDs).
        - Define `input_points` (consumed UUIDs), `output_points`, `internal_state_points`, `setpoint_input_points` (with UUIDs, local names, suffixes) as per ADR-013, Section II.B.2.
    - [ ]  `[ ]` Validate using `build.py` (Stage 2 validation).
- **Task 2.6: Migrate Governor Logic Configs to Component YAMLs (Ref: SSOT Plan PDF Ticket 6.6)**
    - [ ]  `[ ]` For each governor instance:
        - Translate old logic parameters (PID constants, setpoint sources, output targets as UUIDs) into the new `GovernorConfig` YAML format.
        - Define `input_points`, `output_points`, `internal_state_points` as per ADR-013, Section II.B.3.
    - [ ]  `[ ]` Validate using `build.py` (Stage 2 validation).

### Phase 3: `build.py` Implementation & Enhancement

*Goal: Ensure `build.py` can perform comprehensive validation and generate all necessary runtime artifacts from the SSOT.*

- **Task 3.1: Implement/Enhance `build.py` Stage 1: `system_definition.yaml` Structural Validation (Ref: SSOT Plan PDF Decision 3)**
    - [ ]  `[ ]` Ensure `build.py` correctly loads and validates `system_definition.yaml` against Pydantic models from `core_ssot_models.py`.
- **Task 3.2: Implement/Enhance `build.py` Stage 2: Component-Specific YAML Validation (Ref: SSOT Plan PDF Decision 3 & Task B)**
    - [ ]  `[ ]` Ensure `build.py` iterates through components in `system_definition.yaml`, loads their `config_file`, and validates it against the correct Pydantic model from `component_configs.py` (using `COMPONENT_MODEL_MAP`).
- **Task 3.3: Implement/Enhance `build.py` Stage 3: Cross-Validation Logic (Ref: SSOT Plan PDF Decision 3 & Task A)**
    - [ ]  `[ ]` Validate UUID uniqueness across all points in `system_definition.yaml`.
    - [ ]  `[ ]` Validate that all UUIDs referenced in `points_provided`, `virtual_points_provided`, `input_points` (in drivers/governors), `write_point_uuid_ref`, `readback_point_uuid_ref`, `data_point_uuid_ref`, and `readback_point_uuid` (on command points) exist in the master `points:` list.
    - [ ]  `[ ]` Validate `writable_by` entries against existing component `id`s.
    - [ ]  `[ ]` Implement checks for consistency between logical `initial_value` (from `system_definition.yaml`) and hardware `initial_state` (from `MicrocontrollerConfig`) for actuators.
    - [ ]  `[ ]` Implement other internal consistency checks (e.g., state names in driver FSM transitions).
- **Task 3.4: Implement `build.py` Logic for `autogen_config.h` Generation for Microcontrollers (Ref: ADR-013 Sec.II.C, microC Plan P6.4)**
    - [ ]  `[ ]` For each microcontroller component:
        - Merge global (`system_definition.yaml`) and local (`MicrocontrollerConfig`) settings for WiFi, MQTT, NTP.
        - Iterate through `hardware_points` in `MicrocontrollerConfig`.
        - Use the local `name` to generate C++ macro prefixes.
        - Look up master point details from `system_definition.yaml` using `_uuid_ref` fields.
        - Construct full MQTT topics: `GLOBAL_MQTT_PREFIX` + `DEVICE_ID` (component `id`) + `mqtt_topic_suffix_*`.
        - Generate all `#define` macros **as specified in "ADR-013: Naming, UUIDs, SSOT, and Information Locus for System Points", Section II.C ("Contents of autogen_config.h") and its examples.**
    - [ ]  `[ ]` Ensure output matches the manually created `autogen_config.h` structure.
- **Task 3.5: Implement `build.py` Logic for `global_point_registry.json` Generation (Ref: ADR-013 Sec.II.C, microC Plan P6.4)**
    - [ ]  `[ ]` Create a JSON object keyed by point `uuid`.
    - [ ]  `[ ]` For each point from `system_definition.yaml`'s master `points:` list:
        - Determine its `source_component_id` by checking `points_provided`/`virtual_points_provided` in `system_definition.yaml`'s `components` section.
        - Include all master attributes (`name`, `description`, `value_type`, `units`, etc.).
        - Add derived full MQTT topic(s).
        - Add implementation details from component-specific YAML where relevant (e.g., pin for a microcontroller point).
        - Structure this registry as outlined in ADR-013, Section 3 ("Global Point Registry / UUID-Topic Mapping").
    - [ ]  `[ ]` Output the `global_point_registry.json` file.
- **Task 3.6: Implement `build.py` Logic for Other Runtime Artifact Generation (Optional) (Ref: SSOT Plan PDF Task I)**
    - [ ]  `[ ]` Consider generation of Telegraf input snippets based on `global_point_registry.json`.
    - [ ]  `[ ]` Consider generation of ENV files for Dockerized Python services.

### Phase 4: Final Validation, System Integration & Documentation

*Goal: Ensure the entire SSOT system is functional, integrated, and well-documented.*

- **Task 4.1: Full Migrated Config Validation with `build.py` (Ref: SSOT Plan PDF Ticket 6.7)**
    - [ ]  `[ ]` Run `build.py` against the complete set of migrated YAML configuration files.
    - [ ]  `[ ]` Resolve all validation errors (structural, cross-referential).
    - [ ]  `[ ]` Manually review generated artifacts (`autogen_config.h` files, `global_point_registry.json`) for logical correctness and completeness.
- **Task 4.2: Integrate `build.py` into Development Workflow**
    - [ ]  `[ ]` Ensure `build.py` is run automatically (e.g., pre-commit hook, CI pipeline) after any changes to YAML configuration files.
    - [ ]  `[ ]` Failed validation should block commits/merges.
- **Task 4.3: Update/Create System Documentation for SSOT**
    - [ ]  `[ ]` Finalize "ADR-013: Naming, UUIDs, SSOT, and Information Locus for System Points".
    - [ ]  `[ ]` Document the structure of `system_definition.yaml` and all component-specific YAML configuration files, referencing ADR-013.
    - [ ]  `[ ]` Document all Pydantic models in `core_ssot_models.py` and `component_configs.py`.
    - [ ]  `[ ]` Document the usage and stages of `build.py`.
    - [ ]  `[ ]` Document the structure and purpose of `global_point_registry.json`.
    - [ ]  `[ ]` Document the configuration migration process and any mappings used.
    - [ ]  `[ ]` Update `architecture_overview.txt` to reflect the finalized SSOT data flow.