Step 1: Finalize Pydantic Model for PointDefinition in core_ssot_models.py (SSOT Plan Task 1.2)

Action: Review and ensure your PointDefinition Pydantic model (in control/common/config_models/core_ssot_models.py) precisely matches all attributes specified in ADR-013, Section II.A ("Master Point Definition"). This includes uuid, system-wide functional name, description, value_type, units, data_source_layer (as required), access, writable_by, readback_point_uuid, persist_to_db (as required, perhaps with a default), validation_rules, and logical initial_value.
Why: This model will validate your changes to system_definition.yaml.
Step 2: Update Master points: List in system_definition.yaml (SSOT Plan Task 2.2)

Action: Go through every point currently in your system_definition.yaml's points: list.
Assign/Verify uuid: Ensure each point has a globally unique UUID.
Update name: Change the name field to the new system-wide functional name, following ADR-013, Principle #6. (e.g., "Chamber1AmbientTemperature", "MainHeaterWrite"). Avoid embedding pin numbers or old local identifiers here.
Populate/Verify All Other Attributes: Ensure all other fields (description, value_type, units, data_source_layer, access, writable_by, readback_point_uuid, persist_to_db, validation_rules, initial_value) are present and correctly reflect the decisions in ADR-013, Section II.A. Remember lowercase "on"/"off".
Tool: Run build.py (Stage 1 validation) frequently against system_definition.yaml to catch errors based on your updated PointDefinition Pydantic model.
Why: This aligns your primary SSOT data with the new, agreed-upon conventions and structure. This is the critical "renaming and restructuring" step for your master point list.
Step 3: Update components: Section in system_definition.yaml (SSOT Plan Task 2.3)

Action: Review the components: section.
Ensure each component (microcontroller, driver, governor) has its unique id.
Verify config_file paths.
Update points_provided (for microcontrollers) and virtual_points_provided (for drivers/governors) lists for each component to use the correct, updated UUIDs from the master points: list (from Step 2). This establishes the ownership link for each point.
Why: This correctly links components to the points they source, which is essential for build.py to determine source_component_id and correctly construct topics.