Naming, UUIDs, SSOT, and Information Locus for System Points
**Date:** 2025-05-20
**Version:** 1.8 (Clarified actuator readbacks, Pub/Sub in layer descriptions, persist_to_db)

**Context:**

The Mushroom Automation System V2 relies heavily on a Single Source of Truth (SSOT) for all configurations. This includes the definition of all data points within the system, whether they originate from physical hardware, software components, or manual user input. Clear, consistent, and adaptable strategies for naming, uniquely identifying (UUID), and defining the locus of information for these points are crucial for system integrity, maintainability, and scalability.

This ADR builds upon the "Mushroom Automation System V2 - SSOT Implementation Plan & Next Steps" document, which establishes `system_definition.yaml` as the primary SSOT containing the "master point list" and outlines the roles of Pydantic models and `build.py`. This ADR aims to precisely define:

1. Where specific attributes of a point are defined within the SSOT YAML structure.
2. Naming conventions for points.
3. The flow of information from YAML configurations to runtime artifacts like `autogen_config.h` and the `global_point_registry.json`.

**Core Principles for Information Distribution in SSOT (Aligned with SSOT Plan PDF):**

1. **`system_definition.yaml` as the Master Point List & Component Inventory:**
    - This file is the primary SSOT. It contains a comprehensive list of **all data points** in the system within its `points:` section.
    - For each point, `system_definition.yaml` defines its globally unique `uuid` and its core system-level attributes (e.g., `name`, `description`, `value_type`, `units`, `data_source_layer`, `access`, `writable_by`, `readback_point_uuid` (formerly `status_point_uuid`), `persist_to_db`, `validation_rules`, `initial_value`).
    - It also defines all system components (microcontrollers, drivers, governors) in its `components:` section, assigning each a unique `id` (e.g., "c1", "temp_driver_fruiting"). This component `id` is used as the `source_component_id`.
    - Within each component definition in `system_definition.yaml` (e.g., for a microcontroller component with `id: "c1"`), a field like `points_provided` lists the UUIDs (from the master `points:` list) that are sourced or managed by "c1". This explicitly establishes the ownership link which `build.py` uses to determine the `source_component_id` for each point. Similarly, `virtual_points_provided` is used for software components like drivers/governors.
    - `system_definition.yaml` also links to component-specific configuration files where implementation details are found.
    - A global MQTT topic prefix (e.g., "mush/") must be defined in `system_definition.yaml` (e.g., under `global_settings.mqtt_topic_prefix`), to be used by `build.py`.
2. **Component-Specific YAMLs for Implementation Details:**
    - Component-specific YAML files (e.g., `control/config/microcontrollers/c1_config.yaml`) provide the *implementation details* for points *sourced by* that component.
    - For a microcontroller, this includes attributes like `pin` assignments, `pin_mode`, hardware `initial_state` (e.g., `LOW`/`HIGH`), and `mqtt_topic_suffix_*`.
    - These component-specific definitions **must reference the `uuid`(s)** of the point(s) as defined in `system_definition.yaml`'s master point list to ensure linkage. The `name` used locally within the component config should be systematically derived from the master `name` (see Principle #7).
3. **Pydantic Models for Validation:**
    - `core_ssot_models.py` defines Pydantic models (e.g., `SystemDefinition`, `PointDefinition`) for validating `system_definition.yaml`.
    - `component_configs.py` defines Pydantic models (e.g., `MicrocontrollerConfig`, `DriverConfig`, `GovernorConfig`, `HardwarePoint` submodels) for validating component-specific YAML files.
4. **`build.py` as the Consolidator, Validator, and Generator:**
    - Reads `system_definition.yaml` and all linked component-specific YAMLs.
    - Performs multi-stage validation using Pydantic models.
    - Constructs full MQTT topics by combining the global MQTT prefix, the `source_component_id`, and `mqtt_topic_suffix_*` values.
    - Populates the `global_point_registry.json`.
    - Generates `autogen_config.h` for microcontrollers.
5. **UUID as the Immutable Global Identifier:** The `uuid` defined in `system_definition.yaml` is the primary key for a point.
6. **Functional Naming (System-Wide):** The `name` field in `system_definition.yaml` (master `points:` list) provides the primary functional identifier (e.g., "Chamber1AmbientTemperature", "MainHeaterCommand"). It should be descriptive of the point's role in the system, avoiding mutable physical details. If multiple similar functional items exist, their system-wide names must differentiate them (e.g., "Zone1HeaterCommand", "Zone2HeaterCommand"). This name is the basis for deriving other names.
7. **Local Naming (Component-Specific & C++ Macros):** The `name` field within a component-specific YAML (e.g., `MicrocontrollerConfig.HardwarePoint.name`) is used by `build.py` to generate C++ macro prefixes. This local `name` should be systematically derived, typically by prepending the component's ID to the functional part of the system-wide `name` from `system_definition.yaml` (e.g., if system-wide name for a point on "c1" is "AmbientTemperature", the local name in `c1_config.yaml` could be "C1_AmbientTemperature", leading to C++ macros like `PIN_C1_AMBIENTTEMPERATURE`). This makes local names predictable and not arbitrarily chosen.

### I. Point Types by Architectural Layer

This section outlines the typical kinds of data points associated with each layer of the system. The subsequent section will detail where information for these points is stored.

**A. Layer 0: Physical Hardware (Interfaced by Microcontrollers)**
* **Direct Sensor Inputs:** Raw values from sensors connected to microcontroller pins (e.g., analog temperature sensor, digital switch).
* **Complex Sensor Inputs (Multi-Value):** Data from sensors like I2C devices (e.g., SCD41 providing CO2, Temperature, Humidity). Each distinct measured value is treated as a separate point in `system_definition.yaml`.
* **Actuator Outputs:** Control signals for physical actuators (e.g., relay on/off, PWM duty cycle for a fan).
* **Actuator Readbacks:** Feedback from an actuator confirming its state, published by the microcontroller.

**B. Layer 1: Microcontrollers (C1, C2, C3)**
* **Published Physical Sensor Values:** Processed or direct values from L0 sensors, formatted and published via MQTT. Each distinct sensor value (e.g., SCD41 CO2, SCD41 Temperature) is a separate point.
* **Published Actuator Readbacks:** Confirmation of actuator states, published via MQTT.
* **Microcontroller System Information Points (Publish):** Internally generated data (e.g., "C1_Uptime", "C2_LastRestartReason", "C3_WiFi_RSSI"), published via MQTT.
* **Subscribed Actuator Command (Write) Points (Subscribe):** MQTT topics the microcontroller listens to for commands to control L0 actuators.

**C. Layer 2: Drivers (e.g., TemperatureDriver, HumidityDriver)**
* **Driver Input Points (Subscribe - Consumed from Microcontrollers/Data Processing):**
* Sensor values (e.g., "C1_AmbientTemperature" consumed by TemperatureDriver).
* Actuator readbacks (e.g., "C2_HeaterRelayReadback" consumed by TemperatureDriver).
* **Driver Output Points (Publish - Commands to Microcontrollers):** Logical commands generated by the driver's FSM/control logic, intended for specific microcontroller actuators (e.g., "TempDriver_HeaterCommand" which targets the MQTT topic for C2's heater relay write point).
* **Driver Internal State Points (Publish - for Monitoring/Governors):** Information about the driver's own operational state, FSM state, health, last accepted command, etc., published for monitoring or use by Governors (e.g., "TempDriver_FSM_State", "TempDriver_CurrentMode").
* **Driver Configuration/Setpoint Input Points (Subscribe - from Governors/Users):** MQTT topics the driver subscribes to for receiving configuration parameters or setpoints from Governors or Users (e.g., "TempDriver_TargetTemperatureSetpoint").

**D. Layer 2.5: Data Processing Layer**
* **Consumed Input Points (Subscribe):** Raw sensor values, actuator readbacks from microcontrollers.
* **Published Processed/Filtered/Synthetic Sensor Values (Publish):** Calibrated sensor data, averaged values, derived metrics (e.g., "Processed_AmbientTemperature_Avg5Min", "Calculated_VPD").
* **Published Data Quality & Staleness Indicators (Publish).**

**E. Layer 3: Governors (e.g., TemperatureGovernor, EnvironmentGovernor)**
* **Governor Input Points (Subscribe - Consumed from Drivers/Data Processing/User):**
* Processed sensor values (e.g., "Processed_AmbientTemperature_Avg5Min").
* Driver internal states (e.g., "TempDriver_FSM_State").
* User-defined operational mode requests or high-level setpoints.
* **Governor Output Points (Publish - Commands/Setpoints to Drivers):** Logical commands or setpoints generated by the governor's logic (e.g., "EnvGovernor_TempDriver_TargetTempSetpoint", "EnvGovernor_HumidityDriver_ModeCommand").
* **Governor Internal State Points (Publish - for Monitoring):** Information about the governor's own state, active strategy, etc.

**F. Layer 4: User / Manual Interaction Layer**
* **Manual Input Points (Publish - by User):** Points where a user can directly publish a value to influence the system (e.g., manual override for an actuator, a manually entered setpoint). These are typically defined in `system_definition.yaml` with `data_source_layer: manual_input` and appropriate `writable_by` permissions.
* **Consumed Display Points (Subscribe - by Visualization Tools):** Any point in the system that is visualized (e.g., in Grafana).

### II. Information Locus: Where Point Attributes are Defined

**A. Master Point Definition (in `system_definition.yaml` - `points:` list, validated by `PointDefinition` Pydantic model from `core_ssot_models.py`)**

For **every point** in the system:

- `uuid`: (String) Globally unique, immutable identifier. **Primary Key.**
- `name`: (String) Primary system-wide functional name (e.g., "Chamber1AmbientTemperature", "MainHeaterWrite", "C1SystemUptime").
- `description`: (String, Optional) Detailed description.
- `value_type`: (Enum/Literal, e.g., `CONTINUOUS`, `DISCRETE`, `TEXT`).
- `units`: (String, Optional) e.g., "Â°C", "on/off", "%RH", "seconds".
- `data_source_layer`: (Enum/Literal, e.g., `microcontroller`, `driver`, `governor`, `data_processing`, `manual_input`). Required.
- `access`: (Enum/Literal, e.g., `READ_ONLY`, `READ_WRITE`).
- `writable_by`: (List of Strings, Optional) List of `source_component_id`s authorized to publish to this point's topic if `access` is `READ_WRITE`.
- `readback_point_uuid`: (String, Optional) For write/command points, this links to the UUID of the corresponding readback/status point.
- `persist_to_db`: (Boolean) Whether this point's data should be persisted to the time-series database. (Pydantic model for `PointDefinition` can specify a default value, e.g., `True`, if desired, but the attribute is considered for every point).
- `validation_rules`: (Dict, Optional) e.g., `{"allowed_values": ["on", "off"]}`.
- `initial_value`: (Any, Optional) Default/initial logical value for the point (e.g., "off", "on", 20.0). For actuators, this is the desired initial command state.
- `linked_points`: (Dict, Optional).

**B. Component-Specific Implementation Details (in Component YAMLs)**

**B.1. For Microcontroller Points (defined in `MicrocontrollerConfig` YAML, `hardware_points` list):**

- `name`: (String) Local functional name for C++ macro generation, systematically derived (e.g., "C1_" + functional part of master name for the primary UUID this entry implements).
- `point_kind`: (Enum/Literal: `actuator`, `sensor_data`, `system_info`).
- `pin`: (String/Int, Optional).
- `pin_mode`: (Enum/Literal, Optional) e.g., `INPUT`, `OUTPUT`, `INPUT_PULLUP`.
- `initial_state`: (Enum/Literal, Optional) e.g., `LOW`, `HIGH`, `0`. Direct hardware initialization value (e.g., for `digitalWrite()`). For actuators, `build.py` should ensure this aligns with the logical `initial_value` of the corresponding write point from `system_definition.yaml` (e.g., if `initial_value` is "on", `initial_state` should be `HIGH`).
- **For `point_kind: "actuator"`:**
    - `write_point_uuid_ref`: (String) UUID of the **write point** (defined in `system_definition.yaml`) that this physical actuator implements.
    - `readback_point_uuid_ref`: (String) UUID of the **readback point** (defined in `system_definition.yaml`) that this physical actuator implements.
    - `mqtt_topic_suffix_write`: (String) Suffix for the write topic (e.g., "actuators/heater/write"). Microcontroller subscribes.
    - `mqtt_topic_suffix_readback`: (String) Suffix for the readback topic (e.g., "actuators/heater/readback"). Microcontroller publishes.
- **For `point_kind: "sensor_data"` or `"system_info"`:**
    - `data_point_uuid_ref`: (String) UUID of the **data point** (defined in `system_definition.yaml`) that this entry implements.
    - `mqtt_topic_suffix_data`: (String) Suffix for sensor data or system info topic (e.g., "sensors/ambient_temp/data" or "status/uptime"). Microcontroller publishes. The actual path for the suffix is defined by the user in the YAML; "data" is not a mandated part of the suffix itself but rather indicates the *type* of topic this field is for.
- `attributes`: (Dict, Optional).

**B.2. For Driver Points (defined in `DriverConfig` YAML, validated by `DriverConfig` Pydantic model):**

- `component_id`: (String) The unique ID of this driver instance (e.g., "temperature_driver_fruiting"), matching its `id` in `system_definition.yaml`.
- `input_points`: (List of Strings, Optional) List of UUIDs (referencing points in `system_definition.yaml`) that this driver subscribes to or reads from the `global_point_registry.json` (e.g., sensor values, actuator readbacks).
- `output_points`: (List of Dicts, Optional) Defines logical output points that this driver publishes. Each entry would contain:
    - `uuid`: (String) UUID of this driver output point (must match a definition in `system_definition.yaml` where `data_source_layer` is `driver` and `source_component_id` will be this driver).
    - `name`: (String) Local functional name for this output (e.g., "TempDriver_HeaterCommand").
    - `mqtt_topic_suffix_data`: (String) Suffix for the topic this driver publishes to (e.g., "outputs/heater_command").
- `internal_state_points`: (List of Dicts, Optional) Defines points representing the driver's internal FSM state, health, last accepted command, etc. Each entry similar to `output_points` (uuid, name, suffix).
- `setpoint_input_points`: (List of Dicts, Optional) Defines points the driver subscribes to for receiving configuration or setpoints. Each entry includes:
    - `uuid`: (String) UUID of the setpoint input point (defined in `system_definition.yaml`).
    - `name`: (String) Local name for this setpoint.
    - (Topic is known via the UUID from `global_point_registry.json`).
- Other driver-specific configurations (FSM definitions, PID constants if applicable before governor refactor, etc.).

**B.3. For Governor Points (defined in `GovernorConfig` YAML, validated by `GovernorConfig` Pydantic model):**

- `component_id`: (String) The unique ID of this governor instance.
- `input_points`: (List of Strings, Optional) List of UUIDs this governor consumes (e.g., processed sensor values, driver states).
- `output_points`: (List of Dicts, Optional) Defines logical output points (commands/setpoints to drivers). Each entry includes:
    - `uuid`: (String) UUID of this governor output point.
    - `name`: (String) Local functional name.
    - `mqtt_topic_suffix_data`: (String) Suffix for the topic this governor publishes to.
- `internal_state_points`: (List of Dicts, Optional) For governor's own state, active strategy, etc.
- Other governor-specific configurations (logic parameters, target setpoint sources, etc.).

**C. Information Derived by `build.py` (and stored in `global_point_registry.json` and `autogen_config.h`)**

- **`source_component_id`:** Determined from the component `id` in `system_definition.yaml` that lists the point's UUID in its `points_provided` or `virtual_points_provided`.
- **Full MQTT Topics:** Constructed: `GLOBAL_MQTT_PREFIX` + `source_component_id` + `/` + `mqtt_topic_suffix_*`.
    - Example: "mush/" + "c2" + "/" + "actuators/heater/write" -> "mush/c2/actuators/heater/write".
- **Contents of `autogen_config.h`:**
    - `DEVICE_ID` (from `MicrocontrollerConfig`).
    - WiFi, MQTT, NTP configurations.
    - For each `HardwarePoint` entry in `MicrocontrollerConfig` (based on its `name` field in the uC's YAML):
        - `#define POINT_NAME_[LocalName] "[LocalName]"`
        - **Utility of UUIDs in `autogen_config.h`:** While the C++ firmware primarily uses `PIN_...` and `TOPIC_...` defines for direct operations, including `UUID_...` defines provides:
            - **Provenance/Debugging:** Allows logs from the microcontroller to include the globally unique ID of a point, aiding in system-wide debugging and correlation with the `global_point_registry.json`.
            - **Consistency:** Makes `autogen_config.h` a more complete reflection of the point's identity as defined in the SSOT.
            - **Future Extensibility:** Reserved for potential future uses where a uC might need to reference a point by its global UUID.
        - If `point_kind` is "actuator":
            - `#define UUID_[LocalName]_WRITE "[write_point_uuid_ref_Value]"`
            - `#define UUID_[LocalName]_READBACK "[readback_point_uuid_ref_Value]"`
            - `#define TOPIC_[LocalName]_WRITE "[Full_MQTT_Write_Topic_String]"`
            - `#define TOPIC_[LocalName]_READBACK "[Full_MQTT_Readback_Topic_String]"`
        - If `point_kind` is "sensor_data":
            - `#define UUID_[LocalName]_DATA "[data_point_uuid_ref_Value]"`
            - `#define TOPIC_[LocalName]_DATA "[Full_MQTT_Data_Topic_String]"`
        - If `point_kind` is "system_info":
            - `#define UUID_[LocalName]_DATA "[data_point_uuid_ref_Value]"`
            - `#define TOPIC_[LocalName]_DATA "[Full_MQTT_Data_Topic_String]"`
            - *(No PIN, MODE, INITIAL_STATE for system_info)*
        - `#define PIN_[LocalName] [PinNumber]` (if applicable, e.g., for actuator or direct pin sensor)
        - `#define MODE_[LocalName] [PinMode]` (if applicable)
        - `#define INITIAL_STATE_[LocalName] [State]` (e.g., `LOW`, `HIGH`, `0`, if applicable)
    - Timing constants.
    
    **More Complete `autogen_config.h` Example Snippet (Illustrative for C2):**
    
    ```
    // ... (DEVICE_ID, WIFI, MQTT, NTP settings) ...
    
    // From:
    // - name: "C2_HeatingPad"
    //   point_kind: "actuator"
    //   write_point_uuid_ref: "write-uuid-c2-pad"
    //   readback_point_uuid_ref: "readback-uuid-c2-pad"
    //   pin: 26, pin_mode: "OUTPUT", initial_state: "LOW"
    //   mqtt_topic_suffix_write: "actuators/heating_pad/write"
    //   mqtt_topic_suffix_readback: "actuators/heating_pad/readback"
    #define POINT_NAME_C2_HEATINGPAD "C2_HeatingPad"
    #define UUID_C2_HEATINGPAD_WRITE "write-uuid-c2-pad"
    #define UUID_C2_HEATINGPAD_READBACK "readback-uuid-c2-pad"
    #define PIN_C2_HEATINGPAD 26
    #define MODE_C2_HEATINGPAD OUTPUT
    #define INITIAL_STATE_C2_HEATINGPAD LOW
    #define TOPIC_C2_HEATINGPAD_WRITE "mush/c2/actuators/heating_pad/write"
    #define TOPIC_C2_HEATINGPAD_READBACK "mush/c2/actuators/heating_pad/readback"
    
    // From:
    // - name: "C2_ChamberFanSpeed"
    //   point_kind: "actuator" // Assuming a PWM fan
    //   write_point_uuid_ref: "write-uuid-c2-fan"
    //   readback_point_uuid_ref: "readback-uuid-c2-fan" // Optional, if fan reports speed
    //   pin: 27, pin_mode: "OUTPUT", initial_state: "0" // 0% duty
    //   mqtt_topic_suffix_write: "actuators/chamber_fan/write"
    //   mqtt_topic_suffix_readback: "actuators/chamber_fan/readback" // Or "" if no readback topic
    #define POINT_NAME_C2_CHAMBERFANSPEED "C2_ChamberFanSpeed"
    #define UUID_C2_CHAMBERFANSPEED_WRITE "write-uuid-c2-fan"
    #define UUID_C2_CHAMBERFANSPEED_READBACK "readback-uuid-c2-fan"
    #define PIN_C2_CHAMBERFANSPEED 27
    #define MODE_C2_CHAMBERFANSPEED OUTPUT
    #define INITIAL_STATE_C2_CHAMBERFANSPEED 0
    #define TOPIC_C2_CHAMBERFANSPEED_WRITE "mush/c2/actuators/chamber_fan/write"
    #define TOPIC_C2_CHAMBERFANSPEED_READBACK "mush/c2/actuators/chamber_fan/readback" // Or "" if suffix was empty
    
    // From:
    // - name: "C2_AmbientTemp"
    //   point_kind: "sensor_data"
    //   data_point_uuid_ref: "uuid-c2-ambient-temp"
    //   pin: 14, pin_mode: "INPUT" // Example for an analog sensor
    //   mqtt_topic_suffix_data: "sensors/ambient_temp/data"
    #define POINT_NAME_C2_AMBIENTTEMP "C2_AmbientTemp"
    #define UUID_C2_AMBIENTTEMP_DATA "uuid-c2-ambient-temp"
    #define PIN_C2_AMBIENTTEMP 14
    #define MODE_C2_AMBIENTTEMP INPUT
    #define TOPIC_C2_AMBIENTTEMP_DATA "mush/c2/sensors/ambient_temp/data"
    
    // From:
    // - name: "C2_SystemUptime"
    //   point_kind: "system_info"
    //   data_point_uuid_ref: "uuid-c2-uptime"
    //   mqtt_topic_suffix_data: "status/uptime"
    #define POINT_NAME_C2_SYSTEMUPTIME "C2_SystemUptime"
    #define UUID_C2_SYSTEMUPTIME_DATA "uuid-c2-uptime"
    #define TOPIC_C2_SYSTEMUPTIME_DATA "mush/c2/status/uptime"
    // No PIN, MODE, INITIAL_STATE for system_info
    
    // ... (Timing constants) ...
    
    ```
    

**Addressing the "C2_HeatingPad" Example (Illustrative):**

- **In `system_definition.yaml` (`points:` list):**
    
    ```
    - uuid: "readback-uuid-c2-pad"
      name: "C2HeatingPadReadback"
      # ... (value_type: DISCRETE, units: "on/off", data_source_layer: microcontroller, access: READ_ONLY)
    - uuid: "write-uuid-c2-pad"
      name: "C2HeatingPadWrite"
      # ... (value_type: DISCRETE, units: "on/off", data_source_layer: microcontroller, access: READ_WRITE,
      #      writable_by: ["temp_driver_fruiting"], readback_point_uuid: "readback-uuid-c2-pad", initial_value: "off")
    
    ```
    
- **In `control/config/microcontrollers/c2_config.yaml` (`hardware_points:` list):**
    
    ```
    - name: "C2_HeatingPad"  # Local name for C++ macros, derived from system name + component ID
      point_kind: "actuator"
      write_point_uuid_ref: "write-uuid-c2-pad"
      readback_point_uuid_ref: "readback-uuid-c2-pad"
      pin: 26
      pin_mode: "OUTPUT"
      initial_state: "LOW" # Hardware init (digitalWrite(PIN, LOW))
      mqtt_topic_suffix_write: "actuators/heating_pad/write"
      mqtt_topic_suffix_readback: "actuators/heating_pad/readback"
    
    ```
    

This structure ensures each logical point (like a command or a readback) has one UUID in `system_definition.yaml`. The microcontroller's config then details how the physical hardware implements these logical points, referencing their UUIDs.