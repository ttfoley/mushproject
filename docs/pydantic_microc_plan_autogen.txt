**Date:** 2025-05-20
**Version:** 1.3 (Incorporates feedback on actuator readbacks, layer descriptions, and persist_to_db clarification)

**Goal:** To define the Pydantic models necessary for validating microcontroller configurations and to specify the exact structure of the C++ `autogen_config.h` header files that will be generated (initially manually, eventually by `build.py`) from these configurations. This plan supports task P0.3.A and related tasks in the "Microcontroller Refactor Plan (v4)" and aims to integrate microcontroller points into a global UUID-based point registry.

**Important Note on Scope:** This document focuses on the Pydantic models for *microcontroller-specific configurations* (e.g., `c1_config.yaml`) and the structure of the `autogen_config.h` file generated for microcontrollers. System-wide attributes for all points (such as `uuid`, master `name`, `description`, `value_type`, `units`, `data_source_layer`, `access`, `writable_by`, `readback_point_uuid`, `persist_to_db`, `validation_rules`, `initial_value`) are defined in the master point list within `system_definition.yaml` and validated by Pydantic models in `core_ssot_models.py`, as detailed in "ADR-013: Naming, UUIDs, SSOT, and Information Locus for System Points". This plan assumes those master definitions exist.

### 0. Conceptual Point Types by Architectural Layer (Added in v1.3)

*This section, added for context, outlines typical data points by layer. The Pydantic models in Section 1 primarily address how microcontroller-sourced points (Layer B) are configured in their specific YAML files.*

**A. Layer 0: Physical Hardware (Interfaced by Microcontrollers)**
* **Direct Sensor Inputs:** Raw values from sensors connected to microcontroller pins.
* **Complex Sensor Inputs (Multi-Value):** Data from sensors like I2C devices. Each distinct measured value is a separate point.
* **Actuator Outputs:** Control signals for physical actuators.
* **Actuator Readbacks:** Feedback from an actuator confirming its state, published by the microcontroller. **This is considered a required part of a complete actuator interface.**

**B. Layer 1: Microcontrollers (C1, C2, C3)**
* **Published Physical Sensor Values (Publish):** Processed or direct values from L0 sensors, published via MQTT.
* **Published Actuator Readbacks (Publish):** Confirmation of actuator states, published via MQTT.
* **Microcontroller System Information Points (Publish):** Internally generated data (e.g., uptime, last restart reason), published via MQTT.
* **Subscribed Actuator Command (Write) Points (Subscribe):** MQTT topics the microcontroller listens to for commands to control L0 actuators.

**C. Layer 2: Drivers (e.g., TemperatureDriver, HumidityDriver)**
* **Driver Input Points (Subscribe - Consumed from Microcontrollers/Data Processing):**
* Sensor values (e.g., point representing "C1_AmbientTemperature" consumed by TemperatureDriver).
* Actuator readbacks (e.g., point representing "C2_HeaterRelayReadback" consumed by TemperatureDriver).
* **Driver Output Points (Publish - Commands to Microcontrollers):** Logical commands generated by the driver (e.g., point representing "TempDriver_HeaterCommand" which targets the MQTT topic for C2's heater relay write point).
* **Driver Internal State Points (Publish - for Monitoring/Governors):** Information about the driver's own state (e.g., point representing "TempDriver_FSM_State").
* **Driver Configuration/Setpoint Input Points (Subscribe - from Governors/Users):** MQTT topics the driver subscribes to for configuration or setpoints (e.g., point representing "TempDriver_TargetTemperatureSetpoint").

**D. Layer 2.5: Data Processing Layer**
* **Consumed Input Points (Subscribe):** Raw sensor values, actuator readbacks.
* **Published Processed/Filtered/Synthetic Sensor Values (Publish):** Calibrated data, averages, derived metrics.
* **Published Data Quality & Staleness Indicators (Publish).**

**E. Layer 3: Governors (e.g., TemperatureGovernor, EnvironmentGovernor)**
* **Governor Input Points (Subscribe - Consumed from Drivers/Data Processing/User):** Processed sensor values, driver states, user requests.
* **Governor Output Points (Publish - Commands/Setpoints to Drivers):** Logical commands or setpoints.
* **Governor Internal State Points (Publish - for Monitoring):** Governor's own state, active strategy.

**F. Layer 4: User / Manual Interaction Layer**
* **Manual Input Points (Publish - by User):** Points for direct user influence.
* **Consumed Display Points (Subscribe - by Visualization Tools):** Any point visualized.

### 1. Pydantic Models for Microcontroller Configuration

These Python Pydantic models will be used by `build.py` to validate the YAML configuration files for each microcontroller (e.g., `c1_config.yaml`, `c2_config.yaml`). They should reside in a suitable location, such as `control/common/config_models/component_configs.py`.

```
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Literal, Union, Dict, Any
import uuid # For generating default UUIDs if needed, though explicit is better

# --- Basic Configuration Sub-Models (Shared) ---

class WiFiConfig(BaseModel):
    ssid: str
    password: str

class MQTTBrokerConfig(BaseModel):
    """Defines the full MQTT Broker configuration."""
    address: str
    port: int = 1883
    username: Optional[str] = None
    password: Optional[str] = None

class MQTTBrokerConfigOptional(BaseModel):
    """
    Defines MQTT Broker fields that can optionally override global settings.
    If a field is None, the global setting from system_definition.yaml will be used.
    """
    address: Optional[str] = None
    port: Optional[int] = None
    username: Optional[str] = None
    password: Optional[str] = None

class NTPServerConfig(BaseModel):
    """Defines the full NTP Server configuration."""
    address: str = "pool.ntp.org"
    utc_offset_seconds: int = 0
    update_interval_ms: int = 3600000 # 1 hour

class NTPServerConfigOptional(BaseModel):
    """
    Defines NTP Server fields that can optionally override global settings.
    If a field is None, the global setting from system_definition.yaml will be used.
    """
    address: Optional[str] = None
    utc_offset_seconds: Optional[int] = None
    update_interval_ms: Optional[int] = None

# --- Hardware Point Base and Specialized Sub-Models ---
# These models define the structure for the 'hardware_points' list within a MicrocontrollerConfig YAML.
# Each entry here provides implementation details for points whose master definitions are in system_definition.yaml.

class HardwarePointBase_MicrocontrollerImpl(BaseModel): # Renamed to avoid clash if core_ssot_models has a HardwarePointBase
    name: str = Field(..., description="Local, descriptive name for this hardware implementation on the microcontroller (e.g., 'C1_AmbientTemp', 'C2_HeatingElement'). Used to generate C++ define prefixes. Should be systematically derived from the master point name in system_definition.yaml and the device_id.")
    point_kind: str = Field(..., description="Discriminator field: 'actuator', 'sensor_data', 'system_info'.")
    # 'uuid' field here is for linking to the master point definition in system_definition.yaml.
    # For actuators, this might be split into write_point_uuid_ref and readback_point_uuid_ref.
    # For sensors/info, this might be data_point_uuid_ref.
    # This structure aligns with ADR-013's requirement for UUID references.
    description: Optional[str] = Field(None, description="Optional local description for this implementation detail.")
    attributes: Optional[Dict[str, Any]] = Field(None, description="Key-value pairs for additional type-specific configuration for this microcontroller implementation.")

class ActuatorHardwarePoint_MicrocontrollerImpl(HardwarePointBase_MicrocontrollerImpl):
    point_kind: Literal["actuator"] = "actuator"
    write_point_uuid_ref: str = Field(..., description="UUID of the master write point definition in system_definition.yaml.")
    readback_point_uuid_ref: str = Field(..., description="UUID of the master readback point definition in system_definition.yaml.")
    pin: Union[int, str] = Field(..., description="Microcontroller pin for the actuator.")
    pin_mode: Literal["OUTPUT"] = "OUTPUT"
    initial_state: Literal["LOW", "HIGH", "0"] = Field(..., description="Hardware initial state for the actuator ('LOW', 'HIGH', or '0' for PWM 0% duty).")
    mqtt_topic_suffix_write: str = Field(..., description="Suffix for MQTT write topic (e.g., 'actuators/heater/write').")
    mqtt_topic_suffix_readback: str = Field(..., description="Suffix for MQTT readback topic (e.g., 'actuators/heater/readback'). Actuator readbacks are considered essential.")

class SensorDataHardwarePoint_MicrocontrollerImpl(HardwarePointBase_MicrocontrollerImpl):
    point_kind: Literal["sensor_data"] = "sensor_data"
    data_point_uuid_ref: str = Field(..., description="UUID of the master data point definition in system_definition.yaml.")
    pin: Optional[Union[int, str]] = Field(None, description="Microcontroller pin if directly pin-connected.")
    pin_mode: Optional[Literal["INPUT", "INPUT_PULLUP"]] = Field(None, description="Required if 'pin' is specified.")
    mqtt_topic_suffix_data: str = Field(..., description="Suffix for MQTT sensor data topic (e.g., 'sensors/ambient_temp/data').")

    @validator('pin_mode', always=True)
    def check_pin_mode_for_sensor(cls, v, values):
        pin = values.get('pin')
        if pin is not None and v is None:
            raise ValueError("pin_mode ('INPUT' or 'INPUT_PULLUP') is required if 'pin' is specified for a SensorDataHardwarePoint.")
        if pin is None and v is not None:
            raise ValueError("pin_mode should not be set if 'pin' is not specified (e.g., for I2C sensors).")
        return v

class SystemInfoHardwarePoint_MicrocontrollerImpl(HardwarePointBase_MicrocontrollerImpl):
    point_kind: Literal["system_info"] = "system_info"
    data_point_uuid_ref: str = Field(..., description="UUID of the master data point definition in system_definition.yaml.")
    mqtt_topic_suffix_data: str = Field(..., description="Suffix for MQTT system information topic (e.g., 'status/uptime').")

# --- Timing Configuration ---

class TimingConstants(BaseModel):
    wifi_connect_timeout_ms: int = 30000
    mqtt_connect_timeout_ms: int = 20000
    ntp_sync_timeout_ms: int = 15000
    max_time_no_publish_ms: Optional[int] = Field(None, description="Max time in ms a monitored point can go without publishing before a restart is triggered.")
    publish_interval_ms: Optional[int] = Field(None, description="Default interval in ms for publishing data (e.g., sensor readings by the FSM).")

# --- Top-Level Microcontroller Configuration Model ---

class MicrocontrollerConfig(BaseModel):
    """
    Pydantic model for validating a controller-specific YAML configuration file
    (e.g., c1_config.yaml, c2_config.yaml).
    """
    device_id: str = Field(..., description="Unique device ID for this microcontroller. Must match the 'id' in system_definition.yaml.")
    description: str = Field(..., description="Human-readable description of the microcontroller's role.")

    wifi: WiFiConfig
    mqtt_broker: Optional[MQTTBrokerConfigOptional] = Field(None, description="Optional MQTT broker override. If None or fields are None, global settings from system_definition.yaml are used.")
    ntp_server: Optional[NTPServerConfigOptional] = Field(None, description="Optional NTP server override. If None or fields are None, global settings from system_definition.yaml are used.")

    hardware_points: List[Union[ActuatorHardwarePoint_MicrocontrollerImpl, SensorDataHardwarePoint_MicrocontrollerImpl, SystemInfoHardwarePoint_MicrocontrollerImpl]]
    timing_constants: TimingConstants

```

### 2. `autogen_config.h` Structure (Per Microcontroller)

This C++ header file will be generated (initially manually, then by `build.py`) for each microcontroller. `build.py` will iterate through the `hardware_points` list in the validated `MicrocontrollerConfig` Pydantic object. For each point, it will use the local `name` field (e.g., "C2_HeatingElement") to generate unique C++ define prefixes.

**Example for Controller C2 (`microcontroller/controller2/autogen_config.h`):**

```
#ifndef AUTOGEN_CONFIG_H_C2 // Unique header guard per controller
#define AUTOGEN_CONFIG_H_C2

// --- General Device Configuration ---
#define DEVICE_ID "c2"
#define DEVICE_DESCRIPTION "Controller for Actuators (Heater, Fan, etc.)"

// --- WiFi Configuration ---
#define WIFI_SSID "MyWiFiNetworkSSID"
#define WIFI_PASSWORD "MyWiFiPassword"

// --- MQTT Broker Configuration ---
// These values will be derived by build.py from system_definition.yaml global_settings
// or overridden by c2_config.yaml if specified there.
#define MQTT_BROKER_ADDRESS "192.168.1.100"
#define MQTT_BROKER_PORT 1883
#define MQTT_USER "mqtt_username" // Or "" if not defined
#define MQTT_PASSWORD "mqtt_password" // Or "" if not defined

// --- NTP Server Configuration ---
// Similar to MQTT, derived by build.py.
#define NTP_SERVER "pool.ntp.org"
#define NTP_UTC_OFFSET_SECONDS 0
#define NTP_UPDATE_INTERVAL_MS 3600000 // 1 hour

// --- Hardware Point Definitions (from c2_config.yaml hardware_points list) ---

// Example from YAML:
// - name: "C2_HeatingElement"
//   point_kind: "actuator"
//   write_point_uuid_ref: "write-uuid-for-c2-heater"
//   readback_point_uuid_ref: "readback-uuid-for-c2-heater"
//   pin: 12
//   pin_mode: "OUTPUT" // Implied by ActuatorHardwarePoint_MicrocontrollerImpl
//   initial_state: "LOW"
//   mqtt_topic_suffix_write: "actuators/heater/write"
//   mqtt_topic_suffix_readback: "actuators/heater/readback"
#define POINT_NAME_C2_HEATINGELEMENT "C2_HeatingElement"
#define UUID_C2_HEATINGELEMENT_WRITE "write-uuid-for-c2-heater"
#define UUID_C2_HEATINGELEMENT_READBACK "readback-uuid-for-c2-heater"
#define PIN_C2_HEATINGELEMENT 12
#define MODE_C2_HEATINGELEMENT OUTPUT
#define INITIAL_STATE_C2_HEATINGELEMENT LOW
#define TOPIC_C2_HEATINGELEMENT_WRITE "mush/c2/actuators/heater/write"     // Full topic generated by build.py
#define TOPIC_C2_HEATINGELEMENT_READBACK "mush/c2/actuators/heater/readback" // Full topic generated by build.py

// Example from YAML:
// - name: "C2_SystemUptime"
//   point_kind: "system_info"
//   data_point_uuid_ref: "uuid-for-c2-uptime"
//   mqtt_topic_suffix_data: "status/uptime"
#define POINT_NAME_C2_SYSTEMUPTIME "C2_SystemUptime"
#define UUID_C2_SYSTEMUPTIME_DATA "uuid-for-c2-uptime"
// No PIN_, MODE_, INITIAL_STATE_ defines for system_info types
#define TOPIC_C2_SYSTEMUPTIME_DATA "mush/c2/status/uptime" // Full topic

// --- Timing Constants ---
#define WIFI_CONNECT_TIMEOUT_MS 30000
#define MQTT_CONNECT_TIMEOUT_MS 20000
#define NTP_SYNC_TIMEOUT_MS 15000
#define MAX_TIME_NO_PUBLISH_MS 300000 // If defined in c2_config.yaml timing_constants
#define PUBLISH_INTERVAL_MS 60000    // If defined

#endif // AUTOGEN_CONFIG_H_C2

```

### 3. Global Point Registry / UUID-Topic Mapping

A critical outcome of the `build.py` process, beyond generating `autogen_config.h` files, is the creation or augmentation of a **global point registry** (e.g., `global_point_registry.json`). This registry is essential for system-wide discoverability of MQTT topics based on UUIDs.

- **Source of Information:**
    - Master point definitions (UUID, system-wide name, value_type, units, etc.) come from `system_definition.yaml`.
    - Implementation details (like MQTT topic suffixes, `source_component_id`) come from component-specific YAMLs and `system_definition.yaml`'s component inventory.
- **`build.py` Responsibility:**
    - Consolidates information from all sources.
    - Constructs full MQTT topics (Global Prefix + Source Component ID + Suffix).
    - Populates the registry, keyed by UUID, with all relevant metadata including full topics.
- **Structure & Usage:** Refer to ADR-013 for the conceptual structure and usage of this global registry.

### 4. Highlighted Areas for Discussion / Uncertainty (from ADR-013, adapted)

1. **Pydantic `HardwarePoint.pin_mode` & C++ `MODE_...` Defines:**
    - **Decision:** `build.py` passes the string through (e.g., `#define MODE_MYPOINT OUTPUT`).
2. **Pydantic `HardwarePoint.initial_state` & C++ `INITIAL_STATE_...` Defines:**
    - **Decision:** `build.py` translates appropriately. For PWM, `INITIAL_STATE_...` becomes `0` (int). For digital, `LOW` or `HIGH`. `build.py` should validate consistency with the logical `initial_value` from `system_definition.yaml`.
3. **Global vs. Local Timing Constants:**
    - **Decision for now:** Keep global in `TimingConstants` within `MicrocontrollerConfig` for simplicity.
4. **Handling Optional Defines in `autogen_config.h` (e.g., for MQTT topics if a suffix was optional):**
    - **Decision:** For any topic not applicable (e.g., no write topic for a pure sensor), the corresponding `mqtt_topic_suffix_*` field would be absent in the YAML, and `build.py` would define the C++ `TOPIC_...` macro as an empty string (`""`). C++ code checks `strlen() > 0`. (Note: `ActuatorHardwarePoint_MicrocontrollerImpl` now makes `mqtt_topic_suffix_write` and `mqtt_topic_suffix_readback` mandatory).
5. **Pin Mapping (`HardwarePoint.pin` to C++ integer):**
    - **Decision:** `build.py` responsible. Encourage integer GPIOs in YAML. If string aliases (e.g., "D5") are used, `build.py` must resolve them.
6. **`HardwarePointBase_MicrocontrollerImpl.attributes` field:**
    - **Status:** Remains a flexible `Dict[str, Any]` for extensibility.