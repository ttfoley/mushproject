## Comprehensive Microcontroller Refactor Plan (v4)

**Overall Goal:** Refactor and unify firmware for Controllers C1, C2, and C3 to implement ADR-10 MQTT payloads, achieve SSOT-driven configuration (including pins and MQTT topics), enhance robustness with a common C++ framework and FSM utilities, and implement persistent error logging for restart reasons (including no-publish timeouts). This plan depends on and incorporates decisions from ADR-20 and the `ssot_refactor_plan_v1`.

### Phase 0: Foundational Setup & Definitions

*This phase sets the stage for the shared framework and consistent definitions for microcontroller firmware.*

- **[X] P0.1: Define Core FSM States Enumeration:**
    - [X] Define a common `enum State` for the FSM.
    - User Decision on Core States (to be included in the common enum): `[ WAIT, SETUP_HW, CONNECT_WIFI, SYNC_NTP, CONNECT_MQTT, PROCESS_COMMANDS, READ_SENSORS, PUBLISH_DATA, RESTART ]`.
    - User Implementation Notes: "WAIT is still central. SETUP_HW would include things like `scd4x.startLowPowerPeriodicMeasurement()` for C3. Restart Errors are logged with `RestartReasonLogger` at the source of the error (within the failing FSM state) before transitioning directly to `RESTART`."
    - Clarification Note: This list forms the basis of the common enum. Each controller will only implement `case` statements for states relevant to its specific functionality.
- **[X] P0.2: Define Microcontroller Restart Reason Enumeration:**
    - [X] Create a common `enum RestartReason` (e.g., `UNKNOWN_ERROR`, `WIFI_CONNECTION_FAILED`, `MQTT_CONNECTION_FAILED`, `NTP_SYNC_FAILED`, `SENSOR_READ_FAILED`, `COMMAND_PROCESSING_ERROR`, `NO_PUBLISH_TIMEOUT`, `MANUAL_RESTART_COMMAND`).
- **[X] P0.3: Define `RestartReasonLogger` Interface:**
    - [X] Specify the public methods for `RestartReasonLogger` (e.g., `void setup()`, `void storeRestartReason(RestartReason reason, const char* details = nullptr)`, `RestartReason getLastRestartReason(char* detailsBuffer, size_t bufferSize)`, `void clearRestartReason()`).
    - [X] Decide on EEPROM usage strategy (e.g., specific addresses, data structure for storing reason and optional details).
- [ ]  **P0.3.A: Define/Update Pydantic Models for Microcontroller Configurations (Moved to `ssot_refactor_plan_v1` Task 1.3)**
    - [ ]  `This task is now part of the SSOT Refactor Plan. Refer to ssot_refactor_plan_v1 Task 1.3 for defining Pydantic models for MicrocontrollerConfig and its HardwarePoint submodels.`
    - [ ]  `The outcome will be validated YAML structures for microcontroller-specific configurations, linking to master point definitions in system_definition.yaml.`
- **[X] P0.4: Define `autogen_config.h` Target Structure and Plan for Manual Creation (Ref: ADR-013; Generation by `build.py` is in `ssot_refactor_plan_v1` Task 3.4)**
    - [X] Specify the target structure for per-controller `autogen_config.h` files as detailed in ADR-013, Section II.C. This includes:
        - `DEVICE_ID`.
        - WiFi, MQTT (broker, port, user, pass), NTP (server, offset, interval) configurations (values merged from global and local settings by `build.py` eventually).
        - **Hardware Point Definitions (derived from `MicrocontrollerConfig.hardware_points`):**
            - `#define POINT_NAME_[LocalName] "[LocalName]"` (LocalName is systematically derived, e.g., "C1_AmbientTemperature").
            - `#define UUID_[LocalName]_[TYPE] "[Master_UUID_from_system_definition.yaml]"` (e.g., `UUID_C1_AMBIENTTEMPERATURE_DATA`, `UUID_C2_HEATER_WRITE`, `UUID_C2_HEATER_READBACK`). Type can be `WRITE`, `READBACK`, `DATA`.
            - `#define PIN_[LocalName] [PinNumber]` (if applicable).
            - `#define MODE_[LocalName] [PinMode]` (if applicable).
            - `#define INITIAL_STATE_[LocalName] [HardwareState]` (e.g., `LOW`, `HIGH`, `0`, if applicable).
            - `#define TOPIC_[LocalName]_[TYPE] "[FullPathToMQTTTopic]"` (e.g., `TOPIC_C1_AMBIENTTEMPERATURE_DATA "mush/c1/sensors/ambient_temp/data"`). Full path constructed by `build.py` using global prefix, `DEVICE_ID`, and suffix.
        - Critical timing constants (e.g., `WIFI_CONNECT_TIMEOUT_MS`, `MAX_TIME_NO_PUBLISH_MS`).
    - [X] The initial creation of `autogen_config.h` files will be done manually for each controller (C1, C2, C3) based on this detailed structure.
    - [ ]  `Full build.py automation for generating these files is detailed in ssot_refactor_plan_v1 Task 3.4.`
- **[X] P0.5: Define `MonitoredPublishPoint` Base Class Interface:**
    - [X] Define a simple base class (e.g., `MonitoredPublishPoint`) with at least `virtual const char* getPointName() = 0;` (should return the `POINT_NAME_[LocalName]` from `autogen_config.h`) and `unsigned long lastPublishTime = 0;`.
    - [X] This class will be inherited by sensor/actuator data wrappers to facilitate the "no-publish timeout" feature.

### Phase 1: Develop & Test Common Firmware Library

- **[X] P1.1: Develop `JsonBuilder` Service:**
    - [X] Create `JsonBuilder.h` and `JsonBuilder.cpp`.
    - [X] Implement `buildJson(timestamp, value)` methods for various data types, adhering to ADR-10: `{"timestamp": "YYYY-MM-DDTHH:MM:SSZ", "value": ...}`.
    - [X] Use `ArduinoJson` with `StaticJsonDocument`.
    - [X] Unit test `JsonBuilder` functionality.
- **[X] P1.2: Develop `NtpService` Service:**
    - [X] Create `NtpService.h` and `NtpService.cpp`.
    - [X] Implement `begin()`, `update()`, `getFormattedTime()`, `getEpochTime()`, `isTimeSet()`.
    - [X] Include retry logic for initial synchronization.
    - [X] Unit test `NtpService` (mocking WiFi and NTP responses if feasible, otherwise integration testing).
- **[X] P1.3: Develop `MqttService` Service:**
    - [X] Create `MqttService.h` and `MqttService.cpp`.
    - [X] Implement `connect()`, `loop()`, `publish()`, `publishJson()`, `subscribe()`.
    - [X] Implement LWT (`<deviceId>/status` -> "online"/"offline").
    - [X] Implement reconnection logic and message callback mechanism.
    - [X] Unit test `MqttService` (mocking network client and broker interactions if feasible).
- [ ]  **P1.4: Develop Minimal FSM Utilities (`FsmUtils`):**
    - [ ]  Design and implement `FsmUtils.h/.cpp` within `common_firmware_lib`.
    - [ ]  Ensure the common `State` enum (from P0.1) is accessible.
    - [ ]  Implement `const char* stateToString(State state);` for logging.
    - [ ]  Implement `void transitionToState(State &currentStateVariable, State newState, unsigned long &stateEntryTimeMillis);` for standardized state changes and entry time tracking.
    - [ ]  Implement `bool checkTimeout(unsigned long stateEntryTimeMillis, unsigned long timeoutDurationMillis);` for state-specific timeout checks.
    - [ ]  Unit test these utilities.

### Phase 2: Refactor Controller C2 (Actuators Only)

*Goal: Update C2 to use the new common library, FSM structure, and SSOT-driven configuration as per ADR-013 and `autogen_config.h` (initially manual).*

- [ ]  **P2.C2.1: Define C2 Configuration in SSOT-compliant YAML & Manually Create `autogen_config.h`:**
    - [ ]  `Define C2's configuration in control/config/microcontrollers/c2_config.yaml, adhering to the Pydantic models defined in ssot_refactor_plan_v1 Task 1.3. This includes device_id, hardware_points (with local names, point_kind, UUID refs, pin details, MQTT suffixes), etc.`
    - [ ]  `This step aligns with the broader configuration migration detailed in ssot_refactor_plan_v1 Phase 2 (specifically Task 2.4).`
    - [ ]  Manually create/update `microcontroller/controller2/autogen_config.h` based on this YAML and the detailed structure from P0.4 and ADR-013.
- [ ]  **P2.C2.2: Implement `main.cpp` for C2 using FSM Pattern & Common Libraries:**
    - [ ]  Structure `main.cpp` with FSM `switch`, using `FsmUtils`.
    - [ ]  Integrate and use `NtpService`, `MqttService`, and `JsonBuilder` from `common_firmware_lib`.
    - [ ]  Source **all** configurations (WiFi credentials, MQTT broker details, `DEVICE_ID`, NTP server, all MQTT topics via `TOPIC_...` macros, pin definitions via `PIN_...` macros, timeouts) from the manually created `autogen_config.h`.
    - [ ]  Use `PinControl` with `PIN_...` and `MODE_...` defines from `autogen_config.h`.
    - [ ]  Initialize pins using `INITIAL_STATE_...` defines.
    - [ ]  Implement relevant FSM states for C2 (e.g., `SETUP_HW`, `CONNECT_WIFI`, `SYNC_NTP`, `CONNECT_MQTT`, `PROCESS_COMMANDS` subscribing to `TOPIC_..._WRITE`, `PUBLISH_DATA` for actuator readbacks publishing to `TOPIC_..._READBACK`, `WAIT`, `RESTART`).
- [ ]  **P2.C2.3: Implement ADR-10 Payloads for C2 Data (Actuator Readbacks):**
    - [ ]  If C2 publishes actuator readbacks, use `JsonBuilder` and `MqttService::publishJson()` in the `PUBLISH_DATA` state, using `TOPIC_..._READBACK` defines from `autogen_config.h`.
- [ ]  **P2.C2.4: Create Actuator Data Wrappers for C2 (Monitored Points, if applicable):**
    - [ ]  If C2 publishes actuator readbacks that need to be monitored for freshness, create wrappers inheriting from `MonitoredPublishPoint`. The `getPointName()` method should return the `POINT_NAME_...` string from `autogen_config.h`.
    - [ ]  Populate and manage `monitored_points` vector and `lastPublishTime` updates.
- [ ]  **P2.C2.5: Test Controller C2 Thoroughly:**
    - [ ]  Verify WiFi connection, NTP sync, MQTT connection.
    - [ ]  Verify actuator control via MQTT commands (to `TOPIC_..._WRITE`) and readback publication (from `TOPIC_..._READBACK`).
    - [ ]  Test FSM state transitions and basic error handling.

### Phase 3: Refactor Controller C1 (Sensors Only)

*Goal: Update C1 similarly, as per ADR-013 and `autogen_config.h` (initially manual).*

- [ ]  **P3.C1.1: Define C1 Configuration in SSOT-compliant YAML & Manually Create `autogen_config.h`:**
    - [ ]  `Define C1's configuration in control/config/microcontrollers/c1_config.yaml, as per ssot_refactor_plan_v1 Task 1.3 and Task 2.4.`
    - [ ]  Manually create/update `microcontroller/controller1/autogen_config.h`.
- [ ]  **P3.C1.2: Implement `main.cpp` for C1 using FSM Pattern & Common Libraries:**
    - [ ]  Structure `main.cpp` around the FSM `switch` statement.
    - [ ]  Utilize `FsmUtils` (from P1.4) for state transitions, logging, and timeout checks.
    - [ ]  Integrate and use `NtpService`, `MqttService`, and `JsonBuilder` from `common_firmware_lib`.
    - [ ]  Source **all** configurations from the manually created `autogen_config.h`.
    - [ ]  Use the existing `PinControl` library for basic pin I/O, driven by pin definitions in `autogen_config.h`.
    - [ ]  Implement logic for all FSM states relevant to C1 (e.g., `SETUP_HW`, `CONNECT_WIFI`, `SYNC_NTP`, `CONNECT_MQTT`, `READ_SENSORS`, `PUBLISH_DATA` to `TOPIC_..._DATA`, `WAIT`, `RESTART`). Note: C1 does not have actuators, so no `PROCESS_COMMANDS` state related to actuator control.
- [ ]  **P3.C1.3: Implement ADR-10 Payloads for C1 Sensor Data:**
    - [ ]  Within the `PUBLISH_DATA` FSM state, use `JsonBuilder` to format sensor data according to ADR-10.
    - [ ]  Use `MqttService::publishJson()` to send these payloads to `TOPIC_..._DATA` defines from `autogen_config.h`.
- [ ]  **P3.C1.4: Create Sensor Data Wrappers for C1 (Monitored Points):**
    - [ ]  For each distinct data point C1 publishes (e.g., each sensor reading), create a simple wrapper class if not already existing (e.g., `TemperatureSensorWrapper`).
    - [ ]  These wrappers should inherit from `MonitoredPublishPoint` (P0.5). `getPointName()` returns `POINT_NAME_...`.
    - [ ]  In C1's `main.cpp`, create a `std::vector<MonitoredPublishPoint*> monitored_points;` and populate it with instances of these wrappers.
    - [ ]  Update `lastPublishTime` in the respective wrapper object after a successful `MqttService::publishJson()` call for that point.
- [ ]  **P3.C1.5: Test Controller C1 Thoroughly:**
    - [ ]  Verify WiFi connection, NTP sync, MQTT connection.
    - [ ]  Verify sensor data reading and correct ADR-10 publication to configured topics.
    - [ ]  Test FSM state transitions and basic error handling.

### Phase 4: Develop `RestartReasonLogger` & Integrate No-Publish Timeout

*Goal: Implement persistent restart logging and integrate it with the FSMs, including no-publish timeout detection.*

- [ ]  **P4.1: Implement `RestartReasonLogger.h/.cpp` in `common_firmware_lib`:**
    - [ ]  Implement the methods defined in P0.3 using EEPROM for persistence.
    - [ ]  Ensure robust EEPROM read/write operations.
    - [ ]  Unit test `RestartReasonLogger` functionality (e.g., storing, retrieving, clearing reasons).
- [ ]  **P4.2: Integrate `RestartReasonLogger` and No-Publish Timeout in C2:**
    - [ ]  Instantiate `RestartReasonLogger` in C2's `main.cpp`. Call its `setup()` method.
    - [ ]  In relevant FSM states of C2 (e.g., `CONNECT_WIFI`, `SYNC_NTP`, `CONNECT_MQTT` on failure after retries), call `restartLogger.storeRestartReason(REASON, "details")` before transitioning to the `RESTART` state.
    - [ ]  In C2's `IDLE_OPERATIONAL` (or `WAIT`) state, add a periodic check (if C2 has monitored points for actuator readbacks):
        - Iterate through the `monitored_points` vector.
        - For each point, check if `millis() - point->lastPublishTime > MAX_TIME_NO_PUBLISH_MS` (where `MAX_TIME_NO_PUBLISH_MS` is from `autogen_config.h`).
        - If a timeout is detected, call `restartLogger.storeRestartReason(NO_PUBLISH_TIMEOUT, point->getPointName())` and transition to `RESTART`.
    - [ ]  Test restart reason logging and no-publish timeout restarts for C2.
- [ ]  **P4.3: Integrate `RestartReasonLogger` and No-Publish Timeout in C1:**
    - [ ]  Similar integration of `RestartReasonLogger` in C1.
    - [ ]  Implement and test no-publish timeout logic for C1's sensor `monitored_points`.
    - [ ]  Test restart reason logging for C1.

### Phase 5: Refactor Controller C3 (SCD41 Sensor)

*Goal: Update C3 similarly, as per ADR-013 and `autogen_config.h` (initially manual).*

- [ ]  **P5.C3.1: Define C3 Configuration in SSOT-compliant YAML & Manually Create `autogen_config.h`:**
    - [ ]  `Define C3's configuration in control/config/microcontrollers/c3_config.yaml, as per ssot_refactor_plan_v1 Task 1.3 and Task 2.4.`
    - [ ]  Manually create/update `microcontroller/controller3/autogen_config.h`.
- [ ]  **P5.C3.2: Implement `main.cpp` for C3 using FSM Pattern & Common Libraries:**
    - [ ]  Structure `main.cpp` with FSM `switch`, using `FsmUtils`.
    - [ ]  Integrate common library services.
    - [ ]  Source all configurations from `autogen_config.h`.
    - [ ]  Implement SCD41 sensor interaction logic (initialization in `SETUP_HW`, reading in `READ_SENSORS`) using the SparkFun SCD4x library.
    - [ ]  Implement relevant FSM states for C3.
- [ ]  **P5.C3.3: Implement ADR-10 Payloads for C3 Sensor Data:**
    - [ ]  In `PUBLISH_DATA` state, use `JsonBuilder` to format SCD41 sensor readings (CO2, Temperature, Humidity) into separate ADR-10 compliant payloads.
    - [ ]  Use `MqttService::publishJson()` to send these payloads to their respective `TOPIC_..._DATA` defines from `autogen_config.h`.
- [ ]  **P5.C3.4: Create SCD41 Data Wrapper for C3 (Monitored Points):**
    - [ ]  Create wrapper classes for each SCD41 data point (CO2, Temp, Humidity) inheriting from `MonitoredPublishPoint`. `getPointName()` returns `POINT_NAME_...`.
    - [ ]  Populate and manage the `monitored_points` vector in C3's `main.cpp`. Update `lastPublishTime` for each data point after its successful publication.
- [ ]  **P5.C3.5: Integrate `RestartReasonLogger` and No-Publish Timeout in C3:**
    - [ ]  Integrate `RestartReasonLogger` in C3.
    - [ ]  Implement and test no-publish timeout logic for all SCD41 data points (CO2, Temp, Humidity).
    - [ ]  Test restart reason logging for C3.
- [ ]  **P5.C3.6: Test Controller C3 Thoroughly:**
    - [ ]  Verify connectivity, SCD41 sensor readings, and correct ADR-10 publication.
    - [ ]  Test FSM state transitions and error handling, including no-publish timeouts.

### Phase 6: Final Review, Testing, SSOT Automation & Documentation Update

*Goal: Ensure overall system stability, consistency, complete SSOT automation, and documentation.*

- [ ]  **P6.1: Code Review All Controllers & Shared Library:**
    - [ ]  Perform a thorough code review of `common_firmware_lib` (including `FsmUtils`, `RestartReasonLogger`) and the `main.cpp` for C1, C2, and C3.
    - [ ]  Check for consistency, adherence to the plan (including ADR-013), proper error handling, and use of `autogen_config.h`.
- [ ]  **P6.2: System-Level Integration Testing:**
    - [ ]  Run all three controllers simultaneously.
    - [ ]  Verify correct data flow to MQTT broker and into InfluxDB (via Telegraf).
    - [ ]  Test various operational scenarios and induced error conditions (e.g., WiFi/MQTT disconnects, sensor failures if mockable).
- [ ]  **P6.3: Update All Relevant Documentation:**
    - [ ]  Update ADRs if any decisions changed significantly during implementation.
    - [ ]  Update `architecture_overview.txt` to reflect the final microcontroller architecture and SSOT flow.
    - [ ]  Update component descriptions for `common_firmware_lib`.
    - [ ]  Ensure `pydantic_autogen_plan_v1` (ADR-013) is finalized.
    - [ ]  Ensure `READMEs` are up-to-date.
- [ ]  **P6.4: Implement and Test `build.py` Automation for `autogen_config.h` Generation & Global Point Registry (Moved to `ssot_refactor_plan_v1` Phase 3)**
    - [ ]  `This task is now fully detailed in the SSOT Refactor Plan (ssot_refactor_plan_v1, Tasks 3.4 and 3.5).`
    - [ ]  `The outcome will be fully automated generation of autogen_config.h files and the global_point_registry.json, replacing manual steps.`