---
description: 
globs: 
alwaysApply: true
---
Don't ever make changes I don't explictly ask you to.
Don't delete comments unless I ask you to. 
Don't try to "improve" things that I don't ask you to. Focus on the change I'm currently requesting.
Don't making changes deeper than one 2 levels from the code presently being considered without first laying out your plan and asking for approval. 

This is a project to automate the monitoring and growth of mushrooms using arduino/esp32 + python connected via mqtt.
the folder docs/ contains all sort of relevant information, especially folders in the PROJ, ADR, and REQ category. If we're trying to make architectual decisions or debating implementation details, you should search docs/ to see if there's anything relevant to the present problem.
At the beginning of a new chat, you must check out the PROJ files to know what's going on. Here's what's in the docs/:
## Documentation Structure & Search Strategy

### Notion Database Prefixes (docs/ folder):
- **REQ-*** = Requirements (main requirement documents)
- **RAC-*** = Requirements Acceptance Criteria (completion status tracking for the requirements) 
- **ADR-*** = Architecture Decision Records
- **TASK-*** = Tasks
- **EPIC-*** = Epics  
- **PROJ-*** = Project Documentation
- **CODE-*** = Code Documentation
- **TAI-*** = Templates and Instructions
- **DES-*** = Design Documents
- **GEN-*** = Document Generation

### Search Strategy for Requirements:
1. **For requirement details**: Search `REQ-*` files
2. **For acceptance criteria**: Search `RAC-*` files (sparse files with just titles + completion status)
3. **For architecture decisions**: Search `ADR-*` files

### RAC File Format:
- **Sparse files**: Only YAML frontmatter with title + completion status
- **No content**: Just `<!-- This is a sparse entry with properties only -->`
- **Purpose**: Track completion of individual acceptance criteria
- **Search tip**: Use title property for semantic search, not content

### When looking for completion status or acceptance criteria:
- **Always check RAC-* files first**
- **Search by title** since content is sparse
- **Look for `completed: true/false` property**



For every change I request, follow these steps:
1) first consider what functions/files will likely need to be modified based on the change, including downstream effect. Fetch every relevant file and read through them before coming up with solutions. 
2) Come up with 3 different solutions/implementations and choose what you consider the best one. 
3) Once again fetch the relevant code and go through it to see what will be effected and interrogate how your proposed code will interact and modify the existing code. For the effected files, see if the required changes effect yet more code. If you find effects that you didn't initially consider when you came up with the solution, start again at step 1 with this new understanding. Otherwise, proceed to step 4.
4) Explain your choice and the alternatives considered.  For the proposed solution/implementation, consider all of the code that will be effected; enumerate all files/functions that are effected and will need to be modified based on your changes. Explain what you picked, what you learned in the process, and what downstream effects your proposed changes have, including what additional files/code will need to be modified based on the implementation. 
5) Provide a step-by-step, function-by-function, file-by-file implementation plan. 

Intermittently quiz me on changes you make to make sure I understand them.

Don't ever make guesses about what's in the codebase.  If you don't know something, say so. Use tools to look up code not in context. 

Use search tools to get the latest library documentation and examples. Only use the latest. 


Tools:
Pydantic v2 to facilitate config based approach and validation
MQTT mosquitto for communication between the layers
Telegraf to channel MQTT messages
grafana for a dashboard
influxdb for a database
polars for data analysis
Project.io to deal with microcontrollers.
ruff for linting
pytest for testing


