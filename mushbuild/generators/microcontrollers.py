from pathlib import Path
from typing import Any, Dict, Optional

from shared_libs.config_models.core_ssot_models import SystemDefinition, ComponentType, PointUUID
from shared_libs.config_models.component_configs import MicrocontrollerConfig

from mushbuild.utils.topics import TopicResolver


class MicrocontrollerConfigGenerator:
    """Generates autogen_config_<id>.h for microcontrollers (SSOT-derived topics)."""

    def __init__(self, system_config: SystemDefinition, output_dir: Path, infrastructure_config: Optional[Dict[str, Any]] = None):
        self.system_config = system_config
        self.output_dir = output_dir
        self.infrastructure_config = infrastructure_config

    def generate(self, validated_components: Dict[str, Any], only: Optional[str] = None) -> bool:
        print("\n--- Microcontroller Config Header Generation  ---")
        print(f"   Output dir: {self.output_dir}")
        success = True

        if only:
            only_set = {cid.strip() for cid in only.split(',') if cid.strip()}
        else:
            only_set = None

        micros = [c for c in self.system_config.components if c.type == ComponentType.MICROCONTROLLER]
        for comp in micros:
            micro_id = comp.id
            if only_set and micro_id not in only_set:
                continue
            cfg = validated_components.get(micro_id)
            if cfg is None or not isinstance(cfg, MicrocontrollerConfig):
                print(f"❌ No validated MicrocontrollerConfig for '{micro_id}'")
                success = False
                continue
            try:
                header = self._generate_header_content(micro_id, cfg)
                out_file = self.output_dir / f"autogen_config_{micro_id}.h"
                out_file.parent.mkdir(parents=True, exist_ok=True)
                with open(out_file, "w") as f:
                    f.write(header)
                print(f"   ✅ Generated: {out_file}")
            except Exception as e:
                print(f"   ❌ Error generating header for {micro_id}: {e}")
                success = False
        return success

    def _generate_header_content(self, micro_id: str, config: MicrocontrollerConfig) -> str:
        tr = TopicResolver(self.system_config)
        lines: list[str] = []
        lines.append("// autogen_config.h")
        lines.append(f"// Auto-generated configuration header for microcontroller: {micro_id}")
        lines.append(f"// Generated by build.py from system_definition.yaml and {micro_id}_config.yaml")
        lines.append("")
        lines.append("#ifndef AUTOGEN_CONFIG_H")
        lines.append("#define AUTOGEN_CONFIG_H")
        lines.append("")

        # Device identification
        lines.append("// === Device Identification ===")
        lines.append(f'#define DEVICE_ID "{config.device_id}"')
        lines.append(f'#define DEVICE_DESCRIPTION "{config.description}"')
        lines.append(f'#define WIFI_SSID "{config.wifi.ssid}"')
        lines.append(f'#define WIFI_PASSWORD "{config.wifi.password}"')
        lines.append(f'#define MQTT_BROKER_ADDRESS "{config.mqtt.broker_address}"')
        lines.append(f'#define MQTT_BROKER_PORT {config.mqtt.broker_port}')
        lines.append(f'#define MQTT_USERNAME "{config.mqtt.username}"')
        lines.append(f'#define MQTT_PASSWORD "{config.mqtt.password}"')
        lines.append(f'#define MQTT_CLIENT_ID "{config.mqtt.client_id}"')
        lines.append("")

        # Global Settings
        lines.append("// === Global Settings ===")
        lines.append(f'#define NTP_SERVER_ADDRESS "{config.ntp.address}"')
        lines.append(f'#define NTP_UTC_OFFSET_SECONDS {config.ntp.utc_offset_seconds}')
        lines.append(f'#define NTP_UPDATE_INTERVAL_MS {config.ntp.update_interval_ms}')
        lines.append(f'#define DEBUG_I2C_SCAN_ON_STARTUP {"true" if config.debug.i2c_scan_on_startup else "false"}  // Set to false for production builds')
        lines.append("")

        # Comprehensive timing constants (match legacy layout)
        lines.extend(self._emit_timing_constants(config))

        # FSM State Definitions (if provided)
        lines.extend(self._emit_fsm_states(config))

        # I2C Configuration
        lines.append("// === I2C Configuration ===")
        if config.i2c:
            lines.append(f'#define I2C_SDA_PIN {config.i2c.sda_pin}')
            lines.append(f'#define I2C_SCL_PIN {config.i2c.scl_pin}')
        lines.append("")

        # Sensor Configuration Structs / Includes
        if config.i2c_sensors or config.dht_sensors or config.onewire_sensors:
            lines.append("// === Sensor Configuration Structs ===")
            lines.append('#include "sensors/SensorConfigs.h"  // Common sensor config structs (ADR-25)')
            lines.append("")
            lines.append("// === Sensor Configuration Instances ===")
            lines.append("")

        # Sensors: SCD4X, SHT85, BME280
        if config.i2c_sensors:
            for sensor in config.i2c_sensors:
                if getattr(sensor, "type", None) == "SCD4X":
                    lines.extend(self._emit_scd4x_struct(sensor, tr))
                elif getattr(sensor, "type", None) == "SHT85":
                    lines.extend(self._emit_sht85_struct(sensor, tr))
                elif getattr(sensor, "type", None) == "BME280":
                    lines.extend(self._emit_bme280_struct(sensor, tr))

        # DHT22 sensors
        if config.dht_sensors:
            for sensor in config.dht_sensors:
                lines.extend(self._emit_dht22_struct(sensor, tr))

        # DS18B20 sensors
        if config.onewire_sensors:
            for sensor in config.onewire_sensors:
                lines.extend(self._emit_ds18b20_struct(sensor, tr))

        # Actuators (c2)
        if config.actuators:
            lines.append("// === Actuator Configuration Structs ===")
            lines.append('#include "actuators/ActuatorConfigs.h"  // Common actuator config structs (ADR-25)')
            lines.append("")
            lines.append("// === Actuator Configuration Instances ===")
            lines.append("")
            for actuator in config.actuators:
                lines.extend(self._emit_actuator_struct(actuator, tr, config))

        # Status points: compute from UUIDs (emit after actuators if present, else after sensors)
        lines.extend(self._emit_status_points(config, tr))

        # Close header guard
        lines.append("#endif // AUTOGEN_CONFIG_H")
        lines.append("")
        return "\n".join(lines)

    def _emit_timing_constants(self, config: MicrocontrollerConfig) -> list[str]:
        t = config.timing
        lines: list[str] = []
        lines.append("// === Timing Constants ===")
        lines.append(f'#define PUBLISH_INTERVAL_MS {t.publish_interval_ms}')
        lines.append(f'#define WIFI_CONNECT_TIMEOUT_MS {t.wifi_connect_timeout_ms}')
        lines.append(f'#define MQTT_CONNECT_TIMEOUT_MS {t.mqtt_connect_timeout_ms}')
        lines.append(f'#define NTP_SYNC_TIMEOUT_MS {t.ntp_sync_timeout_ms}')
        lines.append(f'#define SENSOR_AND_STATUS_PUBLISH_INTERVAL_MS {t.sensor_and_status_publish_interval_ms}')
        lines.append(f'#define MAX_TIME_NO_PUBLISH_MS {t.max_time_no_publish_ms}')
        lines.append(f'#define STATUS_PUBLISH_INTERVAL_MS {t.status_publish_interval_ms}')
        lines.append(f'#define MAINTENANCE_RESTART_INTERVAL_MS {t.maintenance_restart_interval_ms}')
        lines.append(f'#define PERIODIC_CHECKS_INTERVAL_MS {t.periodic_checks_interval_ms}')
        # Optional actuator republish frequency
        if getattr(t, 'output_republish_frequency_ms', None):
            lines.append(f'#define OUTPUT_REPUBLISH_FREQUENCY_MS {t.output_republish_frequency_ms}')
        lines.append("")
        lines.append("// === FSM and Connection Configuration ===")
        lines.append(f'#define MAX_WIFI_ATTEMPTS {t.max_wifi_attempts}')
        lines.append(f'#define WIFI_ATTEMPT_TIMEOUT_MS {t.wifi_attempt_timeout_ms}')
        lines.append(f'#define MAX_NTP_ATTEMPTS {t.max_ntp_attempts}')
        lines.append(f'#define NTP_ATTEMPT_TIMEOUT_MS {t.ntp_attempt_timeout_ms}')
        lines.append(f'#define MQTT_CONNECT_RETRY_INTERVAL_MS {t.mqtt_retry_delay_ms}')
        lines.append(f'#define NTP_LOOP_UPDATE_INTERVAL_MS {t.ntp_loop_update_interval_ms}')
        lines.append(f'#define DEBUG_QUEUE_INTERVAL_MS {t.debug_queue_interval_ms}')
        lines.append("")
        lines.append("// === Delay and Timing Constants ===")
        lines.append(f'#define MQTT_RETRY_DELAY_MS {t.mqtt_retry_delay_ms}')
        lines.append(f'#define RESTART_DELAY_MS {t.restart_delay_ms}')
        lines.append(f'#define MAIN_LOOP_DELAY_MS {t.main_loop_delay_ms}')
        lines.append("")
        return lines

    def _emit_fsm_states(self, config: MicrocontrollerConfig) -> list[str]:
        lines: list[str] = []
        if config.fsm and config.fsm.states:
            lines.append("// === FSM State Definitions (ADR-17, ADR-22) ===")
            lines.append("// Note: This enum will be used by common FSM utilities")
            lines.append("//All states in FsmUtils.h must be defined here, even if they are not used in this controller.")
            lines.append("typedef enum {")
            for i, state in enumerate(config.fsm.states):
                if i == len(config.fsm.states) - 1:
                    lines.append(f"    {state}             // {self._state_comment(state)}")
                else:
                    lines.append(f"    {state},           // {self._state_comment(state)}")
            lines.append("} FsmState;")
            lines.append("")
        return lines

    def _state_comment(self, state: str) -> str:
        comments = {
            "SETUP_HW": "Hardware initialization (done in setup())",
            "CONNECT_WIFI": "WiFi connection",
            "SYNC_NTP": "NTP synchronization",
            "CONNECT_MQTT": "MQTT broker connection",
            "PUBLISH_BOOT_STATUS": "Publish boot status (restart reason) - runs once after MQTT connection",
            "PROCESS_COMMANDS": "Process actuator commands",
            "READ_SENSORS": "Read sensor values and queue for publishing",
            "PUBLISH_DATA": "Publish data from publish queue",
            "OPERATIONAL_PERIODIC_CHECKS": "Periodic maintenance tasks",
            "WAIT": "Idle state, check what needs to be done",
            "RESTART": "Restart the controller",
        }
        return comments.get(state, "")

    def _emit_scd4x_struct(self, sensor, tr: TopicResolver) -> list[str]:
        lines: list[str] = []
        lines.append(f"// {sensor.point_name} CO2/Temperature/Humidity Sensor Instance")
        lines.append(f"const SCD4xConfig {sensor.instance_name}_CONFIG = {{")
        lines.extend(self._emit_common_sensor_fields(sensor))
        lines.append(f"    .address = 0x{sensor.address:02X},  // SCD4x standard I2C address")
        lines.append(f"    .c_to_f = {self._format_bool(sensor.c_to_f)},")
        # emit topic/uuid pairs
        lines.extend(self._emit_topic_uuid_pair("co2", sensor.co2_uuid, tr, trailing_comma=True))
        lines.extend(self._emit_topic_uuid_pair("temp", sensor.temp_uuid, tr, trailing_comma=True))
        pair = self._emit_topic_uuid_pair("humidity", sensor.humidity_uuid, tr, trailing_comma=False)
        lines.extend(pair)
        lines.append("};")
        lines.append("")
        return lines

    def _emit_sht85_struct(self, sensor, tr: TopicResolver) -> list[str]:
        lines: list[str] = []
        lines.append("// SHT85 Sensor Instance")
        lines.append(f"const SHT85Config {sensor.instance_name}_CONFIG = {{")
        lines.extend(self._emit_common_sensor_fields(sensor))
        lines.append(f"    .address = 0x{sensor.address:02X},")
        lines.append(f"    .c_to_f = {self._format_bool(sensor.c_to_f)},")
        lines.extend(self._emit_topic_uuid_pair("temp", sensor.temperature_uuid, tr, trailing_comma=True))
        pair = self._emit_topic_uuid_pair("humidity", sensor.humidity_uuid, tr, trailing_comma=False)
        lines.extend(pair)
        lines.append("};")
        lines.append("")
        return lines

    def _emit_bme280_struct(self, sensor, tr: TopicResolver) -> list[str]:
        lines: list[str] = []
        lines.append("// BME280 Sensor Instance")
        lines.append(f"const BME280Config {sensor.instance_name}_CONFIG = {{")
        lines.extend(self._emit_common_sensor_fields(sensor))
        lines.append(f"    .address = 0x{sensor.address:02X},")
        lines.append(f"    .c_to_f = {self._format_bool(sensor.c_to_f)},")
        lines.extend(self._emit_topic_uuid_pair("temp", sensor.temperature_uuid, tr, trailing_comma=True))
        lines.extend(self._emit_topic_uuid_pair("humidity", sensor.humidity_uuid, tr, trailing_comma=True))
        pair = self._emit_topic_uuid_pair("pressure", sensor.pressure_uuid, tr, trailing_comma=False)
        lines.extend(pair)
        lines.append("};")
        lines.append("")
        return lines

    def _emit_dht22_struct(self, sensor, tr: TopicResolver) -> list[str]:
        lines: list[str] = []
        lines.append("// DHT22 Sensor Instance")
        lines.append(f"const DHT22Config {sensor.instance_name}_CONFIG = {{")
        lines.extend(self._emit_common_sensor_fields(sensor))
        lines.append(f"    .pin = {sensor.pin},")
        lines.append(f"    .c_to_f = {self._format_bool(sensor.c_to_f)},")
        lines.extend(self._emit_topic_uuid_pair("temp", sensor.temperature_uuid, tr, trailing_comma=True))
        pair = self._emit_topic_uuid_pair("humidity", sensor.humidity_uuid, tr, trailing_comma=False)
        lines.extend(pair)
        lines.append("};")
        lines.append("")
        return lines

    def _emit_ds18b20_struct(self, sensor, tr: TopicResolver) -> list[str]:
        lines: list[str] = []
        lines.append("// DS18B20 Sensor Instance")
        lines.append(f"const DS18B20Config {sensor.instance_name}_CONFIG = {{")
        lines.extend(self._emit_common_sensor_fields(sensor))
        lines.append(f"    .pin = {sensor.pin},")
        lines.append(f"    .resolution_bits = {sensor.resolution_bits},              // {sensor.resolution_bits}-bit resolution = 0.25°C precision, 187.5ms conversion")
        lines.append(f"    .c_to_f = {self._format_bool(sensor.c_to_f)},")
        pair = self._emit_topic_uuid_pair("temp", sensor.temperature_uuid, tr, trailing_comma=False)
        lines.extend(pair)
        lines.append("};")
        lines.append("")
        return lines

    def _emit_actuator_struct(self, actuator, tr: TopicResolver, config: MicrocontrollerConfig) -> list[str]:
        lines: list[str] = []
        lines.append(f"// {actuator.point_name} Actuator Instance")
        lines.append(f"const ActuatorConfig {actuator.instance_name}_CONFIG = {{")
        lines.append(f"    .pin = {actuator.pin},")
        lines.append(f"    .pin_mode = {actuator.pin_mode},")
        lines.append(f"    .initial_state = {actuator.initial_state},")
        lines.append(f'    .point_name = "{actuator.point_name}",')
        # topics
        rb_topic = tr.get_topic(actuator.readback_uuid)
        wr_topic = tr.get_command_write_topic(actuator.readback_uuid) or ""
        lines.append(f'    .write_topic = "{wr_topic}",')
        lines.append(f'    .readback_topic = "{rb_topic}",')
        lines.append(f'    .readback_uuid = "{actuator.readback_uuid}",')
        # timing
        lines.append("    .republish_frequency_ms = OUTPUT_REPUBLISH_FREQUENCY_MS,")
        lines.append("    .max_time_no_publish_ms = MAX_TIME_NO_PUBLISH_MS")
        lines.append("};")
        lines.append("")
        return lines

    def _emit_topic_uuid_pair(self, label: str, uuid: PointUUID, tr: TopicResolver, trailing_comma: bool) -> list[str]:
        """Emit a pair of lines for <label>_topic and <label>_uuid. Control trailing comma on _uuid line."""
        topic = tr.get_topic(uuid)
        topic_line = f'    .{label}_topic = "{topic}",'  # always comma after topic
        uuid_line = f'    .{label}_uuid = "{uuid}"' + ("," if trailing_comma else "")
        return [topic_line, uuid_line]

    def _emit_common_sensor_fields(self, sensor) -> list[str]:
        lines: list[str] = []
        lines.append(f'    .point_name = "{sensor.point_name}",')
        lines.append("    .publish_interval_ms = SENSOR_AND_STATUS_PUBLISH_INTERVAL_MS,")
        lines.append("    .main_loop_delay_ms = MAIN_LOOP_DELAY_MS,")
        lines.append("    .max_time_no_publish_ms = MAX_TIME_NO_PUBLISH_MS,")
        return lines

    def _format_bool(self, value: bool) -> str:
        return "true" if value else "false"

    def _format_hex(self, value: int) -> str:
        return f"0x{value:02X}"

    def _emit_status_points(self, config: MicrocontrollerConfig, tr: TopicResolver) -> list[str]:
        lines: list[str] = []
        # WiFi Uptime
        wifi_uptime = config.status_points.wifi_uptime
        lines.extend([
            f"// System Info: {wifi_uptime.point_name}",
            f'#define POINT_NAME_{wifi_uptime.point_name} "{wifi_uptime.point_name}"',
            f'#define UUID_{wifi_uptime.point_name}_DATA "{wifi_uptime.uuid}"',
            f'#define TOPIC_{wifi_uptime.point_name}_DATA "{tr.get_topic(wifi_uptime.uuid)}"',
            "",
        ])
        # Last Restart Reason
        last_restart = config.status_points.last_restart_reason
        lines.extend([
            f"// System Info: {last_restart.point_name}",
            f'#define POINT_NAME_{last_restart.point_name} "{last_restart.point_name}"',
            f'#define UUID_{last_restart.point_name}_DATA "{last_restart.uuid}"',
            f'#define TOPIC_{last_restart.point_name}_DATA "{tr.get_topic(last_restart.uuid)}"',
            "",
        ])
        return lines

