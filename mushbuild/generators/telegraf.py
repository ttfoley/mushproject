"""
Autogenerate Telegraf config fragments from SSOT.

Outputs docker/config/telegraf/telegraf.d/99-ssot-points.conf with:
- One mqtt_consumer input subscribing to all point topics (from SSOT)
- json_v2 parsing: uuid tag, timestamp from payload, value as string field value_raw
- Per-uuid processors:
  - Continuous: convert value_raw -> float field value (rename + type convert)
  - Discrete/enum: value_raw -> value_label (string field), and enum map to int field

Notes:
- No regex or starlark; deterministic per-uuid logic
- No service restarts; prints a warning if content changed
- Reuses existing broker URL/creds by default (edit DEFAULTS if needed)
"""

from __future__ import annotations

import hashlib
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# Defaults (temporary until secrets/env refactor)
DEFAULTS = {
    "mqtt_server_url": "tcp://192.168.1.17:1883",
    "mqtt_username": "ttfoley",
    "mqtt_password": "password",
}


@dataclass
class PointDef:
    uuid: str
    mqtt_topic: str
    value_type: str  # "CONTINUOUS" | "DISCRETE"
    units: Optional[str]
    allowed_values: Optional[List[str]]
    persist_to_db: bool


def repo_root_from_this_file() -> Path:
    return Path(__file__).resolve().parents[2]


def load_registry(registry_path: Path) -> Dict[str, PointDef]:
    data = json.loads(registry_path.read_text())
    points: Dict[str, PointDef] = {}
    for uuid, p in data["points"].items():
        points[uuid] = PointDef(
            uuid=p["uuid"],
            mqtt_topic=p["mqtt_topic"],
            value_type=p["value_type"],
            units=p.get("units"),
            allowed_values=(p.get("validation_rules") or {}).get("allowed_values"),
            persist_to_db=bool(p.get("persist_to_db", False)),
        )
    return points


def is_boolean_point(pt: PointDef) -> bool:
    # Heuristic: units explicitly "on/off" OR allowed_values exactly of on/off/unknown shape
    if (pt.units or "").strip().lower() == "on/off":
        return True
    if pt.allowed_values:
        lowered = [str(v).strip().lower() for v in pt.allowed_values]
        base = set(["on", "off"])
        if base.issubset(set(lowered)):
            return True
    return False


def build_topics(points: Dict[str, PointDef]) -> List[str]:
    topics = sorted({pt.mqtt_topic for pt in points.values() if pt.persist_to_db and pt.mqtt_topic})
    return topics


def partition_points(points: Dict[str, PointDef]) -> Tuple[List[PointDef], List[PointDef]]:
    continuous: List[PointDef] = []
    discrete: List[PointDef] = []
    for pt in points.values():
        if not pt.persist_to_db:
            continue
        if pt.value_type.upper() == "CONTINUOUS":
            continuous.append(pt)
        else:
            discrete.append(pt)
    return continuous, discrete


def toml_header() -> str:
    lines = [
        "# AUTOGENERATED. Do not edit by hand.",
        "# Source: control/global_points_registry.refactor.json",
        "# Purpose: Subscribe to all SSOT-declared topics and parse new JSON payloads.",
        "",
    ]
    return "\n".join(lines)


def toml_mqtt_input(topics: List[str]) -> str:
    # Single input subscribing to explicit topics for determinism.
    # json_v2: uuid as tag, value as value_raw (string), timestamp from payload.
    topic_items = ",\n    ".join([f'"{t}"' for t in topics])
    return (
        "[[inputs.mqtt_consumer]]\n"
        f"  servers = [\"{DEFAULTS['mqtt_server_url']}\"]\n"
        f"  username = \"{DEFAULTS['mqtt_username']}\"\n"
        f"  password = \"{DEFAULTS['mqtt_password']}\"\n"
        f"  topics = [\n    {topic_items}\n  ]\n"
        "  data_format = \"json_v2\"\n"
        "  topic_tag   = \"topic\"\n"
        "\n"
        "  [[inputs.mqtt_consumer.json_v2]]\n"
        "    measurement_name = \"points\"\n"
        "    [[inputs.mqtt_consumer.json_v2.tag]]\n"
        "      path = \"uuid\"\n"
        "    [[inputs.mqtt_consumer.json_v2.field]]\n"
        "      path = \"value\"\n"
        "      rename = \"value_raw\"\n"
        "    [[inputs.mqtt_consumer.json_v2.timestamp]]\n"
        "      path   = \"timestamp_utc\"\n"
        "      layout = \"2006-01-02T15:04:05.000Z07:00\"\n"
    )


def toml_processors_for_continuous(uuids: List[str]) -> str:
    if not uuids:
        return ""
    uuids_list = ", ".join([f'"{u}"' for u in uuids])
    # Convert value_raw (string) -> float, then rename to value
    return (
        "\n[[processors.converter]]\n"
        "  namepass = [\"points\"]\n"
        f"  tagpass = {{ uuid = [{uuids_list}] }}\n"
        "  [processors.converter.fields]\n"
        "    float = [\"value_raw\"]\n"
        "\n[[processors.rename]]\n"
        "  namepass = [\"points\"]\n"
        f"  tagpass = {{ uuid = [{uuids_list}] }}\n"
        "  [[processors.rename.replace]]\n"
        "    field = \"value_raw\"\n"
        "    dest  = \"value\"\n"
    )


def enum_mapping_block(field_name: str, dest_field: str, mapping: Dict[str, int]) -> str:
    body = [
        "  [[processors.enum.mapping]]",
        f"    field = \"{field_name}\"",
        f"    dest  = \"{dest_field}\"",
        "    default = -1",
        "    [processors.enum.mapping.value_mappings]",
    ]
    for k, v in mapping.items():
        body.append(f"      {k} = {v}")
    return "\n".join(body) + "\n"


def build_enum_mapping(pt: PointDef) -> Dict[str, int]:
    # For boolean, prefer off=0, on=1; unknown=-1 (handled by default)
    mapping: Dict[str, int] = {}
    if is_boolean_point(pt):
        mapping = {"off": 0, "on": 1}
        return mapping
    # Enumerated: map allowed_values in listed order starting at 0
    if pt.allowed_values:
        for i, label in enumerate(pt.allowed_values):
            key = str(label).strip()
            # normalize to bare words for TOML
            mapping[key] = i
    return mapping


def toml_processors_for_discrete(points: List[PointDef]) -> str:
    if not points:
        return ""
    blocks: List[str] = []
    for pt in points:
        # 1) rename value_raw -> value_label (string field)
        blocks.append(
            "\n[[processors.rename]]\n"
            "  namepass = [\"points\"]\n"
            f"  tagpass = {{ uuid = [\"{pt.uuid}\"] }}\n"
            "  [[processors.rename.replace]]\n"
            "    field = \"value_raw\"\n"
            "    dest  = \"value_label\"\n"
        )
        # 2) map label -> code (value_code or state_code)
        mapping = build_enum_mapping(pt)
        dest_field = "state_code" if (pt.units or "").lower() not in ("on/off") and pt.allowed_values else "value_code"
        blocks.append(
            "\n[[processors.enum]]\n"
            "  namepass = [\"points\"]\n"
            f"  tagpass = {{ uuid = [\"{pt.uuid}\"] }}\n"
            + enum_mapping_block("value_label", dest_field, mapping)
        )
    return "".join(blocks)


def render_config(points: Dict[str, PointDef]) -> str:
    topics = build_topics(points)
    cont, disc = partition_points(points)
    cont_uuids = sorted([p.uuid for p in cont])

    parts: List[str] = [toml_header(), toml_mqtt_input(topics)]
    parts.append(toml_processors_for_continuous(cont_uuids))
    parts.append(toml_processors_for_discrete(disc))
    return "\n".join([p for p in parts if p])


def file_hash(text: str) -> str:
    return hashlib.sha256(text.encode("utf-8")).hexdigest()


def main(argv: List[str]) -> int:
    root = repo_root_from_this_file()
    registry_path = root / "control" / "global_points_registry.refactor.json"
    out_path = root / "docker" / "config" / "telegraf" / "telegraf.d" / "99-ssot-points.conf"

    if not registry_path.exists():
        print(f"ERROR: registry not found: {registry_path}", file=sys.stderr)
        return 1

    points = load_registry(registry_path)
    content = render_config(points)
    new_hash = file_hash(content)

    old_hash = None
    if out_path.exists():
        try:
            old_hash = file_hash(out_path.read_text())
        except Exception:
            old_hash = None

    changed = new_hash != old_hash
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(content)

    if changed:
        print(f"[telegraf] WARNING: {out_path.name} content changed. Restart Telegraf to apply.")
    else:
        print(f"[telegraf] No changes to {out_path.name}.")

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))


